<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ming&#39;s Blog</title>
  
  
  <link href="https://bitmingw.com/atom.xml" rel="self"/>
  
  <link href="https://bitmingw.com/"/>
  <updated>2021-04-25T16:56:38.852Z</updated>
  <id>https://bitmingw.com/</id>
  
  <author>
    <name>Ming Wen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ 和 Rust 的移动操作</title>
    <link href="https://bitmingw.com/2021/04/25/move-semantics-in-c++-and-rust/"/>
    <id>https://bitmingw.com/2021/04/25/move-semantics-in-c++-and-rust/</id>
    <published>2021-04-25T07:00:00.000Z</published>
    <updated>2021-04-25T16:56:38.852Z</updated>
    
    <content type="html"><![CDATA[<p>各种编程语言都支持对象（object）的构造、复制、读取、修改和销毁等操作。其中的复制（copy）操作，就是在计算机内存中的某个新地址，构造一个和原对象一模一样的新对象。</p><p>少数语言，例如 C++ 和 Rust，还支持一种叫『移动』（move）的操作。对象的移动，顾名思义，就是把原对象从计算机内存中的某个地址<strong>搬运</strong>至新的地址。听上去，移动操作做的事情似乎和复制差不多。那么为什么 C++ 和 Rust 要引入移动操作呢？为什么其他大多数语言都不支持移动操作呢？</p><span id="more"></span><br /><h2 id="如何使用移动操作"><a href="#如何使用移动操作" class="headerlink" title="如何使用移动操作"></a>如何使用移动操作</h2><p>在讨论移动操作的用途之前，我们需要先了解一下如何在程序中使用移动操作。</p><p>在 C++ 中，当需要在内存中的某个新地址，构造一个和原对象一模一样的新对象的时候，编译器会根据原对象是『左值』（lvalue）还是『右值』（rvalue），来决定是执行复制操作，还是执行移动操作。一个对象是左值还是右值，有一种较为直观（但不十分准确）的判定方法：能被赋值，或者说，能出现在赋值符号 <code>=</code> 左侧的对象是左值，否则就是右值<sup>[1]</sup>。我们通过几个直观的例子来看一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i 是左值。</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即便这回 i 出现在右侧，</span></span><br><span class="line"><span class="comment">// 它还是左值。</span></span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量 10 不能出现在左侧，所以 10 是右值。</span></span><br><span class="line"><span class="number">10</span> = <span class="number">5</span>;  <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMagicNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数运行的结果不能出现在左侧，</span></span><br><span class="line"><span class="comment">// 所以是右值。</span></span><br><span class="line">GetMagicNumber() = <span class="number">5</span>;  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>当 C++ 编译器发现原对象是一个右值对象的引用（rvalue reference），且该对象类型支持移动构造 / 移动赋值时，会执行移动操作，否则会执行复制操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 vec 复制到 vec2，</span></span><br><span class="line"><span class="comment">// 因为此处的 vec 是一个左值对象的引用。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2 = vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">VecGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动操作，</span></span><br><span class="line"><span class="comment">// 因为此处调用 VecGenerator 函数，</span></span><br><span class="line"><span class="comment">// 会得到一个右值对象的引用。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec3 = VecGenerator();</span><br></pre></td></tr></table></figure><p>程序员可以使用 <code>std::move</code> 函数将某一个对象的引用，强制转换为一个右值对象的引用，来触发编译器执行移动操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::move 函数将 vec4 强制转换成</span></span><br><span class="line"><span class="comment">// 右值对象的引用。所以此处会执行移动操作。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec5 = <span class="built_in">std</span>::move(vec4);</span><br><span class="line"></span><br><span class="line"><span class="comment">// vec4 被移动到 vec5 之后，会变成空值，</span></span><br><span class="line"><span class="comment">// 因此下一行会打印 0</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vec4.size();</span><br></pre></td></tr></table></figure><p>移动发生后，被移动的对象（如上例中的 <code>vec4</code>）通常会变成空值。一般来说，程序不应该继续使用被移动的对象，因为从理论上来说它的生命周期已经结束了（转移到了新的对象身上）。不过 C++ 编译器不会禁止这种行为。此外，如果对象的类型不支持移动构造 / 移动赋值，C++ 总是会执行复制操作。复制操作是移动操作无法进行时的备用方案。</p><br /><p>和 C++ 区分左值和右值不同，在 Rust 中使用某个对象构造一个一模一样的新对象时，除了少数基本类型外<sup>[2]</sup>，总是会执行移动操作。如果程序员想要执行复制操作而不是移动操作，需要调用 <code>clone()</code> 方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vec = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 vec 的值移动到 vec2。</span></span><br><span class="line"><span class="keyword">let</span> vec2 = vec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在移动发生后，vec 的生命周期结束，</span></span><br><span class="line"><span class="comment">// Rust 会禁止继续使用被移动的对象。</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, vec.len());  <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 clone() 方法</span></span><br><span class="line"><span class="comment">// 复制 vec2 到 vec3 上。</span></span><br><span class="line"><span class="keyword">let</span> vec3 = vec2.clone();</span><br></pre></td></tr></table></figure><br /><h2 id="移动操作的用途"><a href="#移动操作的用途" class="headerlink" title="移动操作的用途"></a>移动操作的用途</h2><p>C++ 和 Rust 支持移动操作，主要有三方面的用途。</p><p><strong>第一，对于生命周期很短的临时对象，使用移动可以减少复制和销毁操作的次数。</strong></p><p>在上文中，我们已经提到了，下面这段代码会执行一个移动操作，将 <code>VecGenerator</code> 函数的返回值移动到变量 vec3 身上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">VecGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec3 = VecGenerator();</span><br></pre></td></tr></table></figure><p>假如 C++ 不支持移动操作，这段代码在实际运行时会发生什么呢？首先，需要构造一个临时对象，用于存储函数 <code>VecGenerator</code> 的返回值。其次，将这个临时对象的值复制到 <code>vec3</code> 身上。最后一步，销毁那个临时对象。实际执行的步骤看上去会像这个样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = VecGenerator();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec3 = temp;</span><br><span class="line"><span class="comment">// then delete temp</span></span><br></pre></td></tr></table></figure><p>支持移动操作之后，原本需要一个构造、一个复制和一个销毁才能搞定的事情，现在一次移动就完成了，提升了程序的运行效率。</p><p><strong>第二，对于较大的对象，和复制相比，移动的开销要小很多。</strong></p><p>这一点，尤其适用于一些指针或者元数据（metadata）存储在栈（stack）上，而值存储在堆（heap）上的数据类型，比如 C++ 中的 <code>std::vector</code> 和 <code>std::string</code>。</p><p>在 C 和 C++ 中，我们可以使用 <code>sizeof</code> 运算符得到一个对象存储消耗的栈空间的大小。无论是空的 <code>std::vector&lt;int&gt;</code> 对象，还是一个存储了 10000 个整数的 <code>std::vector&lt;int&gt;</code> 对象，在 64 位计算机上 <code>sizeof</code> 运算符返回的结果都是 24：他们在栈上消耗的空间大小是相同的<sup>[3]</sup>。这两个对象的不同之处，是前者不消耗堆空间，而后者会消耗至少 40000 字节的堆空间。</p><p>如果要复制一个空的 <code>vector</code> 对象，我们只需要复制栈上的 24 字节；而如果要复制一个存储了 10000 个整数的 <code>vector</code> 对象，我们不仅要复制栈上的 24 字节，还要复制堆上的 40000 字节。复制一个容器的开销，和这个容器存储的数据大小是成正比的。</p><p>但是移动操作不一样。当一个对象被移动时，我们完全可以只移动它在栈上的部分，而不需要移动它在堆上的部分。因此移动一个 <code>vector</code> 对象，无论这个对象有多大，都只涉及栈上的 24 字节。这个开销和复制相比，通常要小得多。</p><p><strong>第三，对于一些不能复制，或者需要独占所有权的对象，移动操作提供了转移对象所有权的方法。</strong></p><p>某一些类型的对象，例如 C++ 的 <code>std::unique_ptr</code>，是不允许被复制的。之所以不允许复制 <code>unique_ptr</code>，是因为它的设计目标，就是让持有 <code>unique_ptr</code> 的函数能独占该对象的所有权。因为 <code>unique_ptr</code> 不能被复制，所以移动操作就成为了转移该对象所有权的唯一方法。</p><br /><h2 id="为什么多数编程语言不支持移动操作"><a href="#为什么多数编程语言不支持移动操作" class="headerlink" title="为什么多数编程语言不支持移动操作"></a>为什么多数编程语言不支持移动操作</h2><p>为什么大多数编程语言，例如 Java / Go / Python，都不支持移动操作呢？从上面的例子我们已经看到，编程语言支持移动操作，为了和复制区分，肯定会在语法、语义和实现上变得更加复杂。只有移动操作带来了足够的好处，一门语言才有支持它的动力。对于多数编程语言来说，因为复制的开销不大，而且缺乏独占所有权的概念，没有足够的动机去支持移动操作。</p><p>我们在上一节中提到了，复制一个存储了 10000 个整数的 <code>std::vector&lt;int&gt;</code> 是一件开销很大的事情，因为 C++ 会把堆上存储的数据也复制一份，也就是深度复制（deep copy）。</p><p>然而，大多数编程语言在复制时，都不会进行深度复制，而是只进行浅层复制（shallow copy）。比如下面这段 Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="keyword">new</span> Integer[<span class="number">10000</span>]);</span><br><span class="line">List&lt;Integer&gt; list2 = list;</span><br></pre></td></tr></table></figure><p>把 <code>list</code> 复制给 <code>list2</code> 的时候，那 10000 个整数并没有被复制，被复制的只是 <code>list</code> 这个 8 字节大的指针而已。复制一个指针的开销是很低的，根本不需要使用移动操作来优化。</p><p>此外，C++ 和 Rust 语言不支持自动垃圾回收。这两种语言垃圾回收的普遍做法是，由一个函数独占对象的所有权，在函数执行结束时，自动销毁其独占的对象<sup>[4]</sup>。对于 Java / Go / Python 这些支持自动垃圾回收的语言来说，无须发展出一套完善的所有权的机制来进行垃圾回收。</p><p>总而言之，对于大多数编程语言，移动操作既不能改善运行效率，而且因为根本没有所有权的概念，也不需要通过它来实现所有权的转移。不支持对象的移动操作，也就是理所当然的事情了。</p><hr><p>[1] 关于左值和右值的详细定义，参见 <a href="https://en.cppreference.com/w/cpp/language/value_category" title="" target="">C++ 标准</a>。</p><p>[2] 对于如下基本类型，Rust 会进行拷贝而不是移动操作：布尔类型（<code>bool</code>）、字符类型（<code>char</code>）、整数和浮点数类型、以及由这几种类型组成的元组（<code>tuple</code>）。</p><p>[3] 一个 <code>std::vector</code> 对象在 64 位计算机上总是消耗 24 字节的栈空间。其中有 8 字节用于记录 <code>vector</code> 容器中存储的数据个数（<code>size</code>），另外 8 字节记录容器的容量（<code>capacity</code>），还有 8 字节的指针记录实际数据在堆中存放的位置（<code>ptr</code>）。</p><p>[4] 这种资源管理 / 垃圾回收方式有个专门的说法，叫 <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" title="" target="">RAII -- Resource acquisition is initialization</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;各种编程语言都支持对象（object）的构造、复制、读取、修改和销毁等操作。其中的复制（copy）操作，就是在计算机内存中的某个新地址，构造一个和原对象一模一样的新对象。&lt;/p&gt;
&lt;p&gt;少数语言，例如 C++ 和 Rust，还支持一种叫『移动』（move）的操作。对象的移动，顾名思义，就是把原对象从计算机内存中的某个地址&lt;strong&gt;搬运&lt;/strong&gt;至新的地址。听上去，移动操作做的事情似乎和复制差不多。那么为什么 C++ 和 Rust 要引入移动操作呢？为什么其他大多数语言都不支持移动操作呢？&lt;/p&gt;</summary>
    
    
    
    <category term="tutorial" scheme="https://bitmingw.com/categories/tutorial/"/>
    
    
    <category term="programming" scheme="https://bitmingw.com/tags/programming/"/>
    
    <category term="C++" scheme="https://bitmingw.com/tags/C/"/>
    
    <category term="Rust" scheme="https://bitmingw.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>基于时间的 SQL 盲注</title>
    <link href="https://bitmingw.com/2021/02/07/time-based-sql-blind-injection/"/>
    <id>https://bitmingw.com/2021/02/07/time-based-sql-blind-injection/</id>
    <published>2021-02-07T08:00:00.000Z</published>
    <updated>2021-02-08T04:34:16.190Z</updated>
    
    <content type="html"><![CDATA[<p>本博客网站由 nginx 驱动，服务器运行在 AWS 上。与其它有固定公网 IP 的服务器一样，我的服务器也时常受到外界的攻击。今天讲解一种常见的攻击方式：基于时间的 SQL 盲注（time-based blind SQL injection）。</p><span id="more"></span><p>我在 nginx 的用户访问日志 access.log 里面，经常能观测到一些可疑的请求——在 URL 中嵌入了代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 正常的请求</span></span><br><span class="line">GET /2015/01/28/life-in-7th-semester/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 嵌入了代码的请求</span></span><br><span class="line">GET /2015/if(now()=sysdate(),sleep(15),0)/28/life-in-7th-semester/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 正常的请求</span></span><br><span class="line">GET /2018/04/07/deep-simplicity/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 嵌入了代码的请求</span></span><br><span class="line">GET /2018/1%20waitfor%20delay%20&#x27;0:0:15&#x27;%20--%20/07/deep-simplicity/</span><br></pre></td></tr></table></figure><p>和正常的请求相比，这些可疑请求用代码替换掉了原 URL 的一部分：</p><ul><li><code>01</code> 被替换成了 <code>if(now()=sysdate(),sleep(15),0)</code>。</li><li><code>04</code> 被替换成了 <code>1 waitfor delay &#39;0:0:15&#39; -- </code>。注意 URL 中的 <code>%20</code> 是空格的转义字符。</li></ul><p>所以这两段代码分别有什么含义呢？</p><p>经过调查，第一段代码是一个 MySQL 语句。MySQL 支持 <code>if</code> 条件语句，它的格式是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="keyword">condition</span>, <span class="keyword">execute</span> <span class="keyword">when</span> <span class="literal">true</span>, <span class="keyword">execute</span> <span class="keyword">when</span> <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p><code>now()</code> 和 <code>sysdate()</code> 都是 MySQL 的内置函数，用来获取系统当前时间。一般来说 <code>now()</code> 和 <code>sysdate()</code> 的返回值是相同的，也就是这个 <code>if</code> 语句的条件为真。此时 MySQL 会执行 <code>sleep(15)</code>，休眠 15 秒之后返回。</p><p>第二段代码是 Microsoft SQL Server 语句，其中 <code>waitfor delay &#39;0:0:15&#39;</code> 和 MySQL 的 <code>sleep(15)</code> 的作用完全相同。这里连 <code>if</code> 语句都省去了，直接休眠。</p><p>那么，为什么要构造这样的特殊请求，发送到我的服务器上呢？</p><p>很多 web 应用依赖于 URL 获取参数（比如用户名）。攻击者可以构造含有特定代码的 URL，如果未经过滤，这些代码可能会在 SQL 的执行阶段被激活，达成特定的目的。这类攻击方式叫做「SQL 注入」。前文描述的两个可疑请求，都是攻击者在尝试 SQL 注入的例子。</p><p>攻击者向我的服务器发送上述两种特殊构造的 URL，就是想知道他们的 SQL 代码是否会得到执行。如果服务器在 15 秒之后才做出响应，那么攻击者有相当大的把握认为，嵌入的 SQL 代码被执行了。如果服务器响应的时间短于 15 秒，那么攻击者就会知道，嵌入的 SQL 代码一定没有执行。由于探测 SQL 被执行与否取决于服务器的响应时间，因此说这是一种<strong>基于时间的</strong> SQL 注入。一旦攻击者发现 SQL 代码被执行了，就相当于找到了一个 SQL 注入的漏洞。他们之后可以利用这个漏洞控制整个 SQL 服务，盗取数据，或者进一步入侵服务器。</p><p>另一方面，我们不难察觉出，这种攻击有相当大的盲目性。</p><p>首先，攻击者不确定 URL 的哪个部分可能是 SQL 的参数。在第一个例子中，他们选取了 <code>/2015/01/28/</code> 中的 <code>01</code>，并认为这个字段可能会被 SQL 用到。这里的 <code>01</code> 指的是一月份，它是否真的会参与 SQL 查询，攻击者除了尝试之外没有别的办法知晓。</p><p>其次，攻击者不确定数据库的类型。上文中提及的两个例子，第一个是针对 MySQL 的，第二个是针对 SQL Server 的。事实上我还找到了针对 PostgreSQL 的 <code> OR 438=(SELECT 438 FROM PG_SLEEP(15))</code>。攻击者需要尝试每一种数据库，来确定服务器使用的数据库类型。</p><p>总结一下，这种攻击方式，需要在每一个可能成为 SQL 参数的位置，尝试每一种数据库类型，进行 SQL 注入。我们把盲目注入简称为<strong>盲注</strong>，所以这种攻击方式，可以称之为「基于时间的 SQL 盲注」。</p><p>以我对近期 nginx 用户访问日志的分析，在我的服务器上，此类攻击平均每个星期会发生 2000 次左右。让我感到十分安心的是，这个博客是一个静态站点，没有使用任何 SQL 服务，所以再多这样的攻击也注定是徒劳无益的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本博客网站由 nginx 驱动，服务器运行在 AWS 上。与其它有固定公网 IP 的服务器一样，我的服务器也时常受到外界的攻击。今天讲解一种常见的攻击方式：基于时间的 SQL 盲注（time-based blind SQL injection）。&lt;/p&gt;</summary>
    
    
    
    <category term="idea" scheme="https://bitmingw.com/categories/idea/"/>
    
    
    <category term="web" scheme="https://bitmingw.com/tags/web/"/>
    
    <category term="sql" scheme="https://bitmingw.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>2021 年的计划</title>
    <link href="https://bitmingw.com/2021/01/01/2021-plan/"/>
    <id>https://bitmingw.com/2021/01/01/2021-plan/</id>
    <published>2021-01-01T08:00:00.000Z</published>
    <updated>2021-01-02T04:30:38.456Z</updated>
    
    <content type="html"><![CDATA[<p>经历了炼狱一般的 2020 年，每个人都期待着 2021 年能少一些波涛汹涌，多一些风平浪静。尽管没有人知道病毒还会肆虐多久，但是至少，我们可以怀着积极的心态，构思新一年的蓝图。</p><span id="more"></span><p>回望 <a href="https://bitmingw.com/2017/01/01/2017-plan/" title="" target="">2017</a> 和 <a href="https://bitmingw.com/2019/01/01/2019-plan/" title="" target="">2019</a> 的年度规划，不足 50% 的完成率让我深感不安。但是这一切也实属无奈：在这个高度不确定的世界中，每隔几个月，我们都可能因为形势的变化，不得不改变先前的计划。举几个发生过的例子：</p><ol><li>在我的第一个岗位中，掌握分布式系统的基础知识是胜任工作的关键。后来因为种种原因，我换了一个组，发现那里的工作并不需要深入了解分布式系统的知识。因此，没有直接的动力支持我继续学习下去。</li><li>在发表了一篇分析某知名翻墙工具的文章后，我的博客被封锁了一段时间。由于担心回国后可能会被请去喝茶，于是停止了相关文章的更新。</li><li>去年，公司为应对危机采取了一系列举动，致使我的收入明显下滑，这也成为了我选择跳槽的主要原因。为了准备跳槽，我有半年的时间需要把大部分精力投入到 Leetcode 中，因此无法持续更新博客。</li></ol><p>考虑到以前的那些经历，在制订 2021 年度规划时，我决定缩减计划的数量，以便预留足够的时间用于计划外的事务。</p><p>2021 年的计划，主要包含下面几个部分。</p><br /><h2 id="在新的岗位有所作为"><a href="#在新的岗位有所作为" class="headerlink" title="在新的岗位有所作为"></a>在新的岗位有所作为</h2><p>我迄今为止的四年职业生涯，概括起来，是两年的『分布式系统』开发，和两年的『大数据分析』开发。去年底，我加入谷歌，开始涉足第三个领域：『通讯、移动与边缘计算』。以我的粗浅认知，我们要做的事情是，把原本集中于数据中心的资源分散到通讯网络的边缘（入口），以支持物联网和 5G 应用对通讯网络高吞吐量和低延迟的要求。</p><p>这份新的工作，从两个方面来看，都是相当大的挑战。首先，我对计算机网络的知识储备没有太多自信，对通讯网络更是知之甚少。作为这个领域的新人，最紧要的，就是迅速掌握相关的核心知识，理解业务模型和上下游关联。其次，通讯网络对延迟要求很高，大概率会使用 C++ 和 Go 等高性能语言。因为我没有这两种语言的工作经历，所以熟练运用新的编程语言也会成为一大难关。</p><p>我的目标是，经过一年的工作，能够深入理解新领域的业务模型，完成高质量的系统设计和代码实现。</p><br /><h2 id="学习-Rust-语言"><a href="#学习-Rust-语言" class="headerlink" title="学习 Rust 语言"></a>学习 Rust 语言</h2><p>我曾经思考过，像 Java 这样的古老语言，已经越来越不适应现代应用的开发，会不会在十几年之后逐渐没落？现在想想，我当时大可不必思考这个问题，因为不太可能一辈子只依靠 Java 吃饭。就像现在，我的工作或许要改用 C++ 和 Go 语言了。有两门新的语言需要熟练掌握，这已经够辛苦了，为什么还要再花时间学 Rust 呢？如果你是 <a href="https://program-think.blogspot.com/" title="" target="">编程随想博客</a> 的读者，或许还能记起编程君的回答：学编程语言，最重要的是为了学习语言背后的编程范式，这些编程范式是通用的智慧。Lisp 虽然拥有最多的编程范式，但是没有得到广泛应用，它同时也缺乏多线程等现代语言的要素。C++ 和 Rust 也是编程范式的集大成者，且相较之下，Rust 历史包袱少，具备更多的现代元素，是高性能语言冉冉升起的明日之星。</p><p>由于 Rust 语言还没有谷歌的官方支持，因此我不会在工作中使用它。但是，全方位了解这门语言的特性，有助于我认识各类编程范式，在未来写出更优雅的代码。学习 Rust 作为一项长期投资，在事业早期就开始投入，是很有意义的。</p><br /><h2 id="Leetcode-常态化"><a href="#Leetcode-常态化" class="headerlink" title="Leetcode 常态化"></a>Leetcode 常态化</h2><p>我在研究生毕业的时候，由于懒惰，直接签了实习的返聘 offer，跳过了很多人都经历过的、痛苦的找工作过程。时隔四年，当我再一次踏上找工作的旅程，面对几乎是从零开始的 Leetcode，内心的滋味相当复杂。假如下一次，不是我自愿离开公司，而是公司开除了我，我是否能够迅速进入状态开始面试，而不是先花半年的时间刷题？</p><p>把 Leetcode 作为日常的一部分，其实是为了追求自由。在公司抛弃我的时候，它是让我保持平心静气的自由；在我遇见了更好的机会时，它既给了我自抬身价的自由，又是先人一步抢摊登陆的自由。</p><p>当然，这里的目标并不是做完 Leetcode 的全部题目。我的目标是，即便不能每天都做 Leetcode，也应当每周都做，而且平均下来一天至少一道题。我可能会尝试使用不同的语言解题，权且当作是语言学习的课后练习好了。</p><br /><p>关于 2021 年的目标，我先说这么多。还有一些想做却没有列举的事，我们在年终总结见分晓。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;经历了炼狱一般的 2020 年，每个人都期待着 2021 年能少一些波涛汹涌，多一些风平浪静。尽管没有人知道病毒还会肆虐多久，但是至少，我们可以怀着积极的心态，构思新一年的蓝图。&lt;/p&gt;</summary>
    
    
    
    <category term="plan" scheme="https://bitmingw.com/categories/plan/"/>
    
    
    <category term="planning" scheme="https://bitmingw.com/tags/planning/"/>
    
  </entry>
  
  <entry>
    <title>复利的魔法</title>
    <link href="https://bitmingw.com/2020/12/13/compound-interest/"/>
    <id>https://bitmingw.com/2020/12/13/compound-interest/</id>
    <published>2020-12-13T08:00:00.000Z</published>
    <updated>2021-03-06T04:30:47.828Z</updated>
    
    <content type="html"><![CDATA[<p>在美国，有一种叫 401k 的养老金计划。个人和雇主可以每年向 401k 养老金账户存入一定数量的钱，60 岁之后就可以取出来。在 2020 年，个人每年可以向 401k 账户中存入最多 $19500 而不用上税。这个数字给人的直观感受，应该可以用杯水车薪来形容。很难想象，经历 30 年的通货膨胀，每年能支出的养老金却只有两三万，会是一种怎样的生活水平。所以，401k 账户中的养老金，真的能撑到人死的那一天么？</p><p>答案有一些反直觉。需要担心的，不是人还没死，钱就花完了，而是人死了，钱还没花完。假设你所在的公司稍有一些良心，愿意按个人出资的 50% 向你的 401k 账户中存钱。也就是说，每年 401k 账户中新存入的资金有 $29250。如果资产的平均年投资回报率有 7%，如此坚持 30 年，账户的最终余额是 296 万！</p><p>为什么说这个答案反直觉呢？大脑的正常思维是，每年存入 $29250，需要大约 100 年的时间才能达到 296 万。但是实际上，这一过程只需要 30 年。这其中的奥秘，就是复利。在复利的帮助下，资产价值会随着时间流逝指数增长。</p><span id="more"></span><p>怎样才能更好地应用复利，实现财务自由呢？有下面几个要点：</p><p><strong>尽早开始</strong></p><p>由于资产价值随着时间指数增长，投资年限越长，资产价值的增长越显著。同样是每年存入 $29250 和 7% 的投资回报率，30 年之后的资产价值是 296 万，但如果少存 5 年，25 年之后的资产价值只有 198 万，少了将近 100 万。如果只存了 20 年，资产价值则是 128 万，这些钱够不够退休就是一个未知数了。</p><p><strong>投资高回报的项目</strong></p><p>平均年投资回报率对最终的资产价值有决定性的影响。我们先前使用 7% 的投资回报率进行计算，是因为美国标普 500 指数的平均年投资回报率是 7%，所以说 7% 是一个比较合理的参考值。如果股市的涨跌起伏让你很不安，结果选择了投资回报率 5% 的债券，那么 30 年之后你只能拿到 204 万，这个和 296 万的差别还是显而易见的。至于银行定期存款 3% 的投资回报率，只能让 30 年后的余额变成 143 万，这恐怕就不太够了。</p><p>当然，高回报的项目通常也意味着高风险。在投资的最后几年，可以逐步把资金从高回报的项目转移到低风险的项目，减少收益流失的可能性。</p><p><strong>好的雇主很重要</strong></p><p>雇主向 401k 账户中存入的钱，会等比放大资产的收益。也就是说，愿意按个人出资的 50% 贡献 401k 账户的雇主，与一毛不拔的雇主相比，最终的资产价值会多 50%。用上面的例子来解释，这就是 200 万和 300 万之间的差别。所以，尽量选一个有良心的雇主吧。</p><p>最后，建议你使用这个 <a href="https://gist.github.com/bitmingw/1876df73d3cc52837ed90ec1ab0d00b1" title="" target="">Python 复利计算脚本</a> 来实际感受一下复利的魔法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在美国，有一种叫 401k 的养老金计划。个人和雇主可以每年向 401k 养老金账户存入一定数量的钱，60 岁之后就可以取出来。在 2020 年，个人每年可以向 401k 账户中存入最多 $19500 而不用上税。这个数字给人的直观感受，应该可以用杯水车薪来形容。很难想象，经历 30 年的通货膨胀，每年能支出的养老金却只有两三万，会是一种怎样的生活水平。所以，401k 账户中的养老金，真的能撑到人死的那一天么？&lt;/p&gt;
&lt;p&gt;答案有一些反直觉。需要担心的，不是人还没死，钱就花完了，而是人死了，钱还没花完。假设你所在的公司稍有一些良心，愿意按个人出资的 50% 向你的 401k 账户中存钱。也就是说，每年 401k 账户中新存入的资金有 $29250。如果资产的平均年投资回报率有 7%，如此坚持 30 年，账户的最终余额是 296 万！&lt;/p&gt;
&lt;p&gt;为什么说这个答案反直觉呢？大脑的正常思维是，每年存入 $29250，需要大约 100 年的时间才能达到 296 万。但是实际上，这一过程只需要 30 年。这其中的奥秘，就是复利。在复利的帮助下，资产价值会随着时间流逝指数增长。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://bitmingw.com/categories/life/"/>
    
    
    <category term="finance" scheme="https://bitmingw.com/tags/finance/"/>
    
  </entry>
  
  <entry>
    <title>Don&#39;t Use File.separator When Loading Java Resource Files</title>
    <link href="https://bitmingw.com/2020/05/16/do-not-use-file-separator-when-loading-java-resource-files/"/>
    <id>https://bitmingw.com/2020/05/16/do-not-use-file-separator-when-loading-java-resource-files/</id>
    <published>2020-05-16T07:00:00.000Z</published>
    <updated>2021-03-06T04:30:37.183Z</updated>
    
    <content type="html"><![CDATA[<p>Don&#39;t use <a href="https://docs.oracle.com/javase/8/docs/api/java/io/File.html#separator" title="" target="">File.separator</a> when loading resource files into Java. Even though <code>File.separator</code> is created to make Java program portable to different platforms, using it to load resource files will just have opposite effect.</p><span id="more"></span><p>I was working on a project written in Java. A simplified structure of project was like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|--src</span><br><span class="line">  |--main</span><br><span class="line">    |--java</span><br><span class="line">    | |--myproject</span><br><span class="line">    |   |--app</span><br><span class="line">    |     |--Main.java</span><br><span class="line">    |</span><br><span class="line">    |--resources</span><br><span class="line">      |--META-INF</span><br><span class="line">        |--app.properties</span><br></pre></td></tr></table></figure><p>The program tried to load a properties file when it started.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APP_CONF = <span class="string">&quot;META-INF&quot;</span> + File.separator + <span class="string">&quot;app.properties&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        InputStream in = Main.class.getClassLoader().getResourceAsStream(APP_CONF);</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;[ERROR] App configuration &quot;</span> + APP_CONF + <span class="string">&quot; is not found.&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When I tested this program in a ubuntu machine, it worked perfectly. However when I copied the same jar and ran it in a windows machine, it broke and showed the following error message:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] App configuration META-INF\app.properties is not found.</span><br></pre></td></tr></table></figure><p>I unzipped the jar and did see <code>app.properties</code> file under <code>META-INF</code> folder. A <code>ls META\app.properties</code> command also worked. Then why Java couldn&#39;t load that resource file?</p><p>After hours of research I found the answer in <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#getResource-java.lang.String-" title="" target="">Java docs of CLassLoader</a>:</p><blockquote><p>ClassLoader</p><p>public URL getResource(String name)</p><p>Finds the resource with the given name.<br>...<br><strong>The name of a resource is a &#39;/&#39;-separated path name that identifies the resource.</strong></p></blockquote><p>It means that when specifying the resource file to load, you have to use the forward slash <code>/</code> to separate the path. Since in windows the value of <code>File.separator</code> is backward slash <code>\</code>, Java won&#39;t be able to find the resource file.</p><p>In conclusion, to make your Java program portable to windows and some other platforms, you should not use <code>File.separator</code> when loading resource files. Use <code>/</code> instead.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Don&amp;#39;t use &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/File.html#separator&quot; title=&quot;&quot; target=&quot;&quot;&gt;File.separator&lt;/a&gt; when loading resource files into Java. Even though &lt;code&gt;File.separator&lt;/code&gt; is created to make Java program portable to different platforms, using it to load resource files will just have opposite effect.&lt;/p&gt;</summary>
    
    
    
    <category term="info" scheme="https://bitmingw.com/categories/info/"/>
    
    
    <category term="java" scheme="https://bitmingw.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>看懂上市公司财报</title>
    <link href="https://bitmingw.com/2020/04/26/understand-financial-statements/"/>
    <id>https://bitmingw.com/2020/04/26/understand-financial-statements/</id>
    <published>2020-04-26T07:00:00.000Z</published>
    <updated>2021-03-06T04:30:21.738Z</updated>
    
    <content type="html"><![CDATA[<p>今年的股市因为受到新型冠状病毒的影响，走出了不寻常的行情。虽然一只股票的短期走势受到外部因素的影响很大，但它的长期走势，主要是由公司的经营状况来决定的。要想了解一家上市公司的经营状况，最直观的方式是阅读公司的财报。</p><p>在美国上市的公司，有义务在每年和每个季度披露公司财报。年度财报和季度财报都可以在 <a href="https://www.sec.gov/edgar/searchedgar/companysearch.html" title="" target="">SEC</a> 网站上查询。考虑到大部分行业都具备一定的季节性，分析公司基本面一般会重点考察年度财报。</p><p>大多数公司的年度财报通常有 50 页以上，可见其中包含的内容极为丰富。作为投资者，我们最关心的有如下一些信息：</p><ol><li>公司在过去的一年中，收入和支出分别是多少。这些信息可以从损益表（income statement）中获取。</li><li>公司当前的资产和负债分别有多少。这些信息记录在资产负债表（balance sheet）中。</li><li>过去一年中，公司账户上现金数额的变化及其原因。现金流量表（cash flow statement）里包含了这方面的信息。</li></ol><p>下面以苹果公司 2019 年度的财报为例，提取上面三个维度的信息。注意，本文的分析结果仅供参考，并没有推荐购买相应的股票。</p><br /><span id="more"></span><h2 id="损益表"><a href="#损益表" class="headerlink" title="损益表"></a>损益表</h2><p>损益表记录了苹果公司 2018 财年和 2019 财年的销售收入和支出（单位：百万美元，下同）。</p><table><thead><tr><th align="left"></th><th align="left"></th><th align="right">2019-09-28</th><th align="right">2018-09-29</th></tr></thead><tbody><tr><td align="left">net sales</td><td align="left"></td><td align="right"></td><td align="right"></td></tr><tr><td align="left"></td><td align="left">products</td><td align="right">213,883</td><td align="right">225,847</td></tr><tr><td align="left"></td><td align="left">services</td><td align="right">46,291</td><td align="right">39,748</td></tr><tr><td align="left"></td><td align="left">total net sale</td><td align="right">260,174</td><td align="right">265,595</td></tr><tr><td align="left"></td><td align="left"></td><td align="right"></td><td align="right"></td></tr><tr><td align="left">cost of sales</td><td align="left"></td><td align="right"></td><td align="right"></td></tr><tr><td align="left"></td><td align="left">products</td><td align="right">144,996</td><td align="right">148,164</td></tr><tr><td align="left"></td><td align="left">services</td><td align="right">16,786</td><td align="right">15,592</td></tr><tr><td align="left"></td><td align="left">total cost of sale</td><td align="right">161,782</td><td align="right">163,756</td></tr><tr><td align="left"></td><td align="left">gross margin</td><td align="right">98,392</td><td align="right">101,839</td></tr></tbody></table><p>苹果公司把自己的销售收入分成了两个大类：产品收入和服务收入。产品收入主要是指 iPhone, iPad, Mac 等硬件产品的收入。服务收入则包含 AppStore, Apple TV, iCloud 等服务的收入。每一项收入，会对应一个营收成本（例如用于组装 iPhone 的零部件的成本，或者运营 iCloud 服务器的成本）。收入与营收成本之差也就是毛利（gross margin）。毛利与销售收入的比值是毛利率。</p><p>从财报中可以得出，苹果公司在 2018 财年和 2019 财年的毛利率分别为 38.3% 和 37.8%。</p><table><thead><tr><th align="left"></th><th align="left"></th><th align="right">2019-09-28</th><th align="right">2018-09-29</th></tr></thead><tbody><tr><td align="left">operating expenses</td><td align="left"></td><td align="right"></td><td align="right"></td></tr><tr><td align="left"></td><td align="left">research and development</td><td align="right">16,217</td><td align="right">14,236</td></tr><tr><td align="left"></td><td align="left">selling, general and administrative</td><td align="right">18,245</td><td align="right">16,705</td></tr><tr><td align="left"></td><td align="left">total operating expenses</td><td align="right">34,462</td><td align="right">30,941</td></tr><tr><td align="left"></td><td align="left"></td><td align="right"></td><td align="right"></td></tr><tr><td align="left">operating income</td><td align="left"></td><td align="right">63,930</td><td align="right">70,898</td></tr><tr><td align="left">other income / (expense)</td><td align="left"></td><td align="right">1,807</td><td align="right">2,005</td></tr><tr><td align="left">income before taxes</td><td align="left"></td><td align="right">65,737</td><td align="right">72,903</td></tr><tr><td align="left">income taxes</td><td align="left"></td><td align="right">10,481</td><td align="right">13,372</td></tr><tr><td align="left">net income</td><td align="left"></td><td align="right">55,256</td><td align="right">59,531</td></tr></tbody></table><p>除了营收成本以外，公司还有许多其他的运营开支，例如研发开支，销售开支，管理开支等。去除了所有这些开支后就得到了营业收入（operating income）。营业收入通常会构成公司税前收入的大部分，它扣除税金后就得到了公司的净收入（net income）。苹果公司在 2019 年的净收入为 552 亿美元。</p><p>从损益表中可以计算一个重要的指标——销货报酬率/净利润率（net margin）。净利润率是净收入与销售收入的比值。苹果公司 2019 年的净利润率是 21.2%，也就是销售收入的 21.2% 转化成了纯利润。<strong>一般来说，一家好的公司应具备 15% 以上的净利润率。</strong></p><br /><h2 id="资产负债表"><a href="#资产负债表" class="headerlink" title="资产负债表"></a>资产负债表</h2><p>资产负债表会列出企业从创办开始到现在，累积的资产、负债以及资产净值。它始终保证下面这个等式成立：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">资产（asset） &#x3D; 负债（liability） + 资产净值（equity）</span><br></pre></td></tr></table></figure><p>下面的表格列举了苹果公司在 2018 财年底和 2019 财年底的流动资产（current assets）。流动资产通常指能在一年时间内转化成现金的资产。它主要包括下面几个类别：</p><ol><li>现金与现金等价物（cash and cash equivalents）</li><li>公司持有的股票、债券、贷款等（marketable securities）</li><li>应收账款（account receivable），即客户应当交付而尚未交付的钱，例如买手机分期付款的钱</li><li>库存（inventories）</li></ol><table><thead><tr><th align="left"></th><th align="left"></th><th align="right">2019-09-28</th><th align="right">2018-09-29</th></tr></thead><tbody><tr><td align="left">current assets</td><td align="left"></td><td align="right"></td><td align="right"></td></tr><tr><td align="left"></td><td align="left">cash and cash equivalents</td><td align="right">48,844</td><td align="right">25,913</td></tr><tr><td align="left"></td><td align="left">marketable securities</td><td align="right">51,713</td><td align="right">40,388</td></tr><tr><td align="left"></td><td align="left">accounts receivable</td><td align="right">22,926</td><td align="right">23,186</td></tr><tr><td align="left"></td><td align="left">inventories</td><td align="right">4,106</td><td align="right">3,956</td></tr><tr><td align="left"></td><td align="left">vendor non-trade receivable</td><td align="right">22,878</td><td align="right">25,809</td></tr><tr><td align="left"></td><td align="left">other current assets</td><td align="right">12,352</td><td align="right">12,087</td></tr><tr><td align="left"></td><td align="left">total current assets</td><td align="right">162,819</td><td align="right">131,339</td></tr></tbody></table><p>此外公司还有一部分非流动资产（non-current assets）。这些资产的流动性较差，通常不能在一年时间内转化为现金。非流动资产主要包括：</p><ol><li>长期债券和贷款（marketable securities）</li><li>房屋等固定资产（property, plant and equipment）</li></ol><p>它们在财报中是这样记录的：</p><table><thead><tr><th align="left"></th><th align="left"></th><th align="right">2019-09-28</th><th align="right">2018-09-29</th></tr></thead><tbody><tr><td align="left">non-current assets</td><td align="left"></td><td align="right"></td><td align="right"></td></tr><tr><td align="left"></td><td align="left">marketable securities</td><td align="right">105,341</td><td align="right">170,799</td></tr><tr><td align="left"></td><td align="left">property, plant and equipment</td><td align="right">37,378</td><td align="right">41,304</td></tr><tr><td align="left"></td><td align="left">Other non-current assets</td><td align="right">32,978</td><td align="right">22,283</td></tr><tr><td align="left"></td><td align="left">total non-current assets</td><td align="right">175,697</td><td align="right">234,386</td></tr><tr><td align="left">total assets</td><td align="left"></td><td align="right">338,516</td><td align="right">365,725</td></tr></tbody></table><p>从财报中可以看出，苹果公司在 2019 财年底拥有的资产总值为 3385 亿美元，其中现金资产 488 亿美元。</p><p>有了净收入和资产总值，我们可以计算第二个重要的指标——资产收益率（return on assets）。资产收益率是净收入与资产总值的比值。苹果公司在 2019 财年的资产收益率是 16.3%。<strong>通常情况下，一家靠谱的公司应具备 6% 以上的资产收益率。</strong></p><p>与资产对应的是负债。先来看看财报对负债的记录：</p><table><thead><tr><th align="left"></th><th align="left"></th><th align="right">2019-09-28</th><th align="right">2018-09-29</th></tr></thead><tbody><tr><td align="left">current liabilities</td><td align="left"></td><td align="right"></td><td align="right"></td></tr><tr><td align="left"></td><td align="left">accounts payable</td><td align="right">46,236</td><td align="right">55,888</td></tr><tr><td align="left"></td><td align="left">other current liabilities</td><td align="right">37,720</td><td align="right">33,327</td></tr><tr><td align="left"></td><td align="left">deferred revenue</td><td align="right">5,522</td><td align="right">5,966</td></tr><tr><td align="left"></td><td align="left">commercial paper</td><td align="right">5,980</td><td align="right">11,964</td></tr><tr><td align="left"></td><td align="left">term debt</td><td align="right">10,260</td><td align="right">8,784</td></tr><tr><td align="left"></td><td align="left">total current liabilities</td><td align="right">105,718</td><td align="right">115,929</td></tr><tr><td align="left">non-current liabilities</td><td align="left"></td><td align="right"></td><td align="right"></td></tr><tr><td align="left"></td><td align="left">term debt</td><td align="right">91,807</td><td align="right">93,735</td></tr><tr><td align="left"></td><td align="left">other non-current liabilities</td><td align="right">50,503</td><td align="right">48,914</td></tr><tr><td align="left"></td><td align="left">total non-current liabilities</td><td align="right">142,310</td><td align="right">142,649</td></tr><tr><td align="left">total liabilities</td><td align="left"></td><td align="right">248,028</td><td align="right">258,578</td></tr></tbody></table><p>与资产类似，负债也分为流动负债（current liabilities）和长期债务（non-current liabilities）。流动负债指公司在一年之内需偿还的债务。债务一般包括这么几个类别：</p><ol><li>应付账款（accounts payable），即已收到供应商的货物或服务，尚未交付的欠款</li><li>递延收入（deferred revenue），即已收到客户提前预支的费用，尚未交付的产品与服务</li><li>有期限债务（term debt），需按照约定时间偿还的债务</li></ol><p>资产与负债的差值是资产净值。它主要由两个部分组成：</p><ol><li>公司股东为了换取股票而为公司提供的资金（common stock and additional paid-in capital）</li><li>公司的留存收益（retained earnings）</li></ol><p>其中，公司的留存收益代表着公司从成立以来，挣到手且尚未花出去的钱的总额。</p><p>从净收入和资产净值，可以计算第三个重要的指标——净资产收益率/股权回报率（return on equity）。股权回报率是净收入占资产净值的比例。<strong>一家好公司应当具备 15% 以上的股权回报率。</strong>苹果公司以 61.1% 的股权回报率远远超出了这个标准。</p><br /><h2 id="现金流量表"><a href="#现金流量表" class="headerlink" title="现金流量表"></a>现金流量表</h2><p>损益表记录了公司运作中应当计入的收益和支出，但由于应计的收益和支出不完全等同于实际的收益和支出，因此损益表不能用来表示公司账户余额的变化。</p><p>举个例子，假如苹果公司允许客户以六个月分期付款的方式购买 iPhone。苹果公司将这部 iPhone 售出的时刻，便可以将整个 iPhone 的销售价格计入公司收益，尽管公司要在接下来的六个月时间里分批拿到这笔钱。</p><p>现金流量表的作用，就是在损益表的基础上进行修正，展示公司实际账户余额的变化。</p><p>现金流的变化主要有三个来源：公司的日常运营、公司的投资活动、公司的金融活动。公司的日常运营是现金流最重要的来源，当公司从日常运营中获取稳定的现金流后，就可以将这笔钱用于投资（例如扩大再生产）和金融活动（回购股票和派发股息）。</p><table><thead><tr><th align="left"></th><th align="right">2019-09-28</th><th align="right">2018-09-29</th></tr></thead><tbody><tr><td align="left">cash, cash equivalents and restricted cash, beginning balances</td><td align="right">25,913</td><td align="right">20,289</td></tr><tr><td align="left">cash generated by operating activities</td><td align="right">69,391</td><td align="right">77,434</td></tr><tr><td align="left">cash generated by investing activities</td><td align="right">45,896</td><td align="right">16,066</td></tr><tr><td align="left">cash used in financing activities</td><td align="right">(90,976)</td><td align="right">(87,876)</td></tr><tr><td align="left">cash, cash equivalents and restricted cash, ending balances</td><td align="right">50,224</td><td align="right">25,913</td></tr></tbody></table><p>从上面的财报中可以看到，苹果公司在 2019 财年初持有的现金及等价物总额为 259 亿美元。在 2019 财年中，公司日常运营和投资活动分别使得现金增加了 693 亿和 458 亿美元。在支出 909 亿美元用于金融活动后，2019 财年底，苹果公司持有的现金及等价物总额为 502 亿美元。</p><p>公司从日常运营中获取的现金，减去投资需要消耗的现金，便是公司的自由现金流（free cash flow）。自由现金流是公司可以任意支配而不影响持续运营的资金。<strong>第四个重要的指标是自由现金流与销售收入的比值，5% 以上说明公司具备强有力的获取自由现金流的能力。</strong>对于苹果公司来说，这个比值高达 40.3%，因此股票价格一路飞涨也是理所当然的事情了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今年的股市因为受到新型冠状病毒的影响，走出了不寻常的行情。虽然一只股票的短期走势受到外部因素的影响很大，但它的长期走势，主要是由公司的经营状况来决定的。要想了解一家上市公司的经营状况，最直观的方式是阅读公司的财报。&lt;/p&gt;
&lt;p&gt;在美国上市的公司，有义务在每年和每个季度披露公司财报。年度财报和季度财报都可以在 &lt;a href=&quot;https://www.sec.gov/edgar/searchedgar/companysearch.html&quot; title=&quot;&quot; target=&quot;&quot;&gt;SEC&lt;/a&gt; 网站上查询。考虑到大部分行业都具备一定的季节性，分析公司基本面一般会重点考察年度财报。&lt;/p&gt;
&lt;p&gt;大多数公司的年度财报通常有 50 页以上，可见其中包含的内容极为丰富。作为投资者，我们最关心的有如下一些信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;公司在过去的一年中，收入和支出分别是多少。这些信息可以从损益表（income statement）中获取。&lt;/li&gt;
&lt;li&gt;公司当前的资产和负债分别有多少。这些信息记录在资产负债表（balance sheet）中。&lt;/li&gt;
&lt;li&gt;过去一年中，公司账户上现金数额的变化及其原因。现金流量表（cash flow statement）里包含了这方面的信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面以苹果公司 2019 年度的财报为例，提取上面三个维度的信息。注意，本文的分析结果仅供参考，并没有推荐购买相应的股票。&lt;/p&gt;
&lt;br /&gt;</summary>
    
    
    
    <category term="tutorial" scheme="https://bitmingw.com/categories/tutorial/"/>
    
    
    <category term="finance" scheme="https://bitmingw.com/tags/finance/"/>
    
  </entry>
  
  <entry>
    <title>Migrate VMware Workstation / Fusion VM to ESXi</title>
    <link href="https://bitmingw.com/2020/02/12/migrate-local-vm-to-esxi/"/>
    <id>https://bitmingw.com/2020/02/12/migrate-local-vm-to-esxi/</id>
    <published>2020-02-12T08:00:00.000Z</published>
    <updated>2021-03-06T04:30:12.116Z</updated>
    
    <content type="html"><![CDATA[<p>I used to run a VM in my mac with VMware Fusion. As my mac is getting older, the VM is becoming slower and slower. One day I got an ESXi host which had sufficient resource to run that VM, but migration from VMware Fusion to ESXi was not a straight forward task. If you are facing similar problem with VMware Workstation or Fusion, the following steps will help you.</p><span id="more"></span><br /><h2 id="Step-1-Export-VMDK"><a href="#Step-1-Export-VMDK" class="headerlink" title="Step 1: Export VMDK"></a>Step 1: Export VMDK</h2><p>Assuming you want to migrate this VM in your local environment:</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2020-02-12-migrate-local-vm-to-esxi/source-vm.png"></div><p>First you need to export the VM, which contains the VMDK file you will need to transfer to the ESXi host.</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2020-02-12-migrate-local-vm-to-esxi/export-ovf.png"></div><p>A VM can be export as a single OVA file, or two separate files (OVF file + VMDK file). The recommendation is choosing separate files, since only VMDK file is needed in later steps.</p><br /><h2 id="Step-2-Upload-and-Convert-VMDK"><a href="#Step-2-Upload-and-Convert-VMDK" class="headerlink" title="Step 2: Upload and Convert VMDK"></a>Step 2: Upload and Convert VMDK</h2><p>When the export finishes, you can use <code>scp</code> to upload the VMDK file to ESXi datastore.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@esxi:&#x2F;vmfs&#x2F;volumes&#x2F;datastore] ls</span><br><span class="line">...</span><br><span class="line">Windows-10-64-Enterprise-disk1.vmdk</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>The VMDK format between ESXi and VMware Workstation / Fusion is different, so the uploaded file can&#39;t be consumed by ESXi directly. There is a command <code>vmkfstools</code> to convert Workstation and Fusion VMDK into ESXi&#39;s format. Let&#39;s rename the uploaded VMDK and do the conversion.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root...] mv Windows-10-64-Enterprise-disk1.vmdk Windows-10-64-Enterprise-disk1.vmdk.fusion</span><br><span class="line">[root...] vmkfstools -i Windows-10-64-Enterprise-disk1.vmdk.fusion Windows-10-64-Enterprise-disk1.vmdk</span><br><span class="line">Destination disk format: VMFS zeroedthick</span><br><span class="line">Cloning disk &#39;Windows-10-64-Enterprise-disk1.vmdk.fusion&#39;...</span><br><span class="line">Clone: 100% done.</span><br></pre></td></tr></table></figure><p>Now you should have the following files in the datastore:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root...] ls</span><br><span class="line">...</span><br><span class="line">Windows-10-64-Enterprise-disk1-flat.vmdk</span><br><span class="line">Windows-10-64-Enterprise-disk1.vmdk</span><br><span class="line">Windows-10-64-Enterprise-disk1.vmdk.fusion</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&quot;Windows-10-64-Enterprise-disk1.vmdk.fusion&quot; is the original VMDK you uploaded. &quot;Windows-10-64-Enterprise-disk1.vmdk&quot; and &quot;Windows-10-64-Enterprise-disk1-flat.vmdk&quot; are the new files generated by <code>vmkfstools</code> command.</p><br /><h2 id="Step-3-Create-New-VM-with-VMDK"><a href="#Step-3-Create-New-VM-with-VMDK" class="headerlink" title="Step 3: Create New VM with VMDK"></a>Step 3: Create New VM with VMDK</h2><p>Now you can create a new VM with the generated VMDK in the datastore. The UI may be different in your environment.</p><p>Click &quot;New Virtual Machine...&quot;.</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2020-02-12-migrate-local-vm-to-esxi/create-new-vm.png"></div><p>In creation type, select &quot;Create a new virtual machine&quot;.</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2020-02-12-migrate-local-vm-to-esxi/create-new-vm-01.png"></div><p>In customize hardware, click the cross at the right of &quot;New Hard disk *&quot; to remove the default disk assigned to this virtual machine.</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2020-02-12-migrate-local-vm-to-esxi/create-new-vm-07a.png"></div><p>Then click &quot;ADD NEW DEVICE&quot; -&gt; &quot;Existing Hard Disk&quot;, and select the generated VMDK file.</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2020-02-12-migrate-local-vm-to-esxi/create-new-vm-07b.png"></div><div style="text-align: center">    <img src="https://bitmingw.com/assets/2020-02-12-migrate-local-vm-to-esxi/create-new-vm-07c.png"></div><p>After that, you should be able to see the generated VMDK is listed as &quot;Disk File&quot;.</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2020-02-12-migrate-local-vm-to-esxi/create-new-vm-07d.png"></div><p>When everything is correct, move forward to create and start VM. Now you should be able to access the VM from Workstation or Fusion even though it is running in ESXi.</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2020-02-12-migrate-local-vm-to-esxi/access-new-vm.png"></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;I used to run a VM in my mac with VMware Fusion. As my mac is getting older, the VM is becoming slower and slower. One day I got an ESXi host which had sufficient resource to run that VM, but migration from VMware Fusion to ESXi was not a straight forward task. If you are facing similar problem with VMware Workstation or Fusion, the following steps will help you.&lt;/p&gt;</summary>
    
    
    
    <category term="tutorial" scheme="https://bitmingw.com/categories/tutorial/"/>
    
    
    <category term="ESXi" scheme="https://bitmingw.com/tags/ESXi/"/>
    
    <category term="VMware" scheme="https://bitmingw.com/tags/VMware/"/>
    
    <category term="vSphere" scheme="https://bitmingw.com/tags/vSphere/"/>
    
  </entry>
  
  <entry>
    <title>2019 年终总结</title>
    <link href="https://bitmingw.com/2019/12/29/2019-retrospect/"/>
    <id>https://bitmingw.com/2019/12/29/2019-retrospect/</id>
    <published>2019-12-29T08:00:00.000Z</published>
    <updated>2021-03-06T04:29:54.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创业路上"><a href="#创业路上" class="headerlink" title="创业路上"></a>创业路上</h2><p>从 2017 年 2 月开始，我在 VMware 工作已经有近三年的时间了。前两年在平台组做了一系列项目，大部分和分布式系统治理有关。不能否认在那里学到了很多知识技能，但总有一天我会彻底厌倦看日志修 bug 的循环往复。2019 年 3 月，我换了一个组，投入到了新产品的开发工作中。</p><p>进组的时机正逢项目从第一行代码起步。全组像一家创业公司：我们有大致的目标和方向，但所有的宏观设计和微观实现都需要自己摸索。与许多其他创业公司一样，踩各类知名开源软件的坑是大家都会经历的事情。</p><p>我们的项目决定使用 <a href="https://druid.apache.org/" title="" target="">druid</a> 作为时间序列数据库。新数据通过 <a href="https://kafka.apache.org/" title="" target="">kafka</a> 源源不断进来，经索引后存放在数据库中，这一过程称为数据摄取。官网上的文档和例子还算齐全，示例程序运行起来也一切正常，但换成我们自己的数据后就立刻出现各类错误，以至于不得不深挖源码一探究竟。这么一个看似照葫芦画瓢的任务，最后花费了我三天时间。</p><p>之后我们想比较两种不同的数据摄取方式，其中一种依赖于 twitter 某个 scala 开源库的两年前的代码。那些代码过于古老，存在一系列编译和运行的问题。每一次运行，我都觉得，这是最后一个错误，再过片刻就可以把程序跑通了。但每一次，又会出现新的错误。那些莫名其妙的异常信息迷惑着我，但我没有时间探索这个开源库的细枝末节，与其确切地知道为什么会出错，不如凭借直觉把解决的方法猜出来。经历近一星期的煎熬，我终于跑通了流水线，拿到了两种方案的对比结果。我们最后没有选择这套开源库，但我不认为这是一项做完即被丢弃和遗忘的工作。对创业公司而言，知道为什么某种方式不好，并且有理有据地避开它，可能会在未来节约不小的成本 [1]。</p><p>从三月到九月，经历过一周连续五天的 war room，经历过打团战从上午十点到晚上九点半，经历过周六周日接连两天来公司点外卖，我们终于发布了产品的第一个版本。正当所有人想好好庆祝一下的时候，我们的客服电话被打爆了。</p><span id="more"></span><p>用户报告的故障主要来源于证书交换环节，这里面有不少可以算是我的“功劳”。因为本人不是安全专家，以前未曾参与过证书管理相关功能的开发，测试工程师也没有注意到许多企业用户可能会使用自己的证书替换系统默认证书，于是出现了产品部署后因无法建立信任，导致数据摄入失败，服务整体停摆的问题。我和几位同事一道，在一个多月的时间里接听了十几通类似的电话，受到影响的客户包括法国第二大银行 Crédit Agricole 等跨国巨头。万幸的是，这次产品质量风波似乎没有影响到来自第三世界国家的客户，让我避免了被派遣并被暴打一顿的下场 [2]。</p><p>以前我觉得，产品做成什么样子就应该说成什么样子，不能搞虚假宣传。做了这个项目之后，我现在觉得，宣传的效果、做出来的效果，以及客户最后看到的效果，必定是有差别的。如果兢兢业业工作，让这三者之间的差别不那么大，就可以问心无愧了。</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2019-12-29-2019-retrospect/NSX-Intelligence-1.png">    <p>产品宣传效果</p></div><div style="text-align: center">    <img src="https://bitmingw.com/assets/2019-12-29-2019-retrospect/NSX-Intelligence-2.png">    <p>内部测试效果</p></div><div style="text-align: center">    <img src="https://bitmingw.com/assets/2019-12-29-2019-retrospect/NSX-Intelligence-3.png">    <p>客户实际运行效果</p></div><p>[1] 关于节约成本，我们避开了公司内部某集成测试框架，节省了很多分拣 bug 的时间；我原先的组没有避开公司内部某数据库，导致过长达数月的项目延期。</p><p>[2] 据传闻，某韩国公司的中国分部曾因产品质量问题，试图殴打我公司派遣去现场维护的工程师。</p><br /><h2 id="不如真人"><a href="#不如真人" class="headerlink" title="不如真人"></a>不如真人</h2><p>我以前是不太拍摄照片的。在亚特兰大，我不过是作业写累了去河边散步，顺手拿出 iPhone 捕捉灿烂的夕阳，或者步道两旁的黄叶。如今，模特的出现，使得摄影的主题发生了巨大变化，同时对摄影效果提出了苛刻的要求。</p><p>首先，给这位模特照相的主要目的是供她发 Instagram，所以那些无足痛痒的街边风景全然没有意义，几乎唯一剩下的主题是记录她的生活点滴。</p><p>第二，虽说现实中不少网红都是拿手机拍照的，但是为了在气势上不输别人，顺便为了拍出更好的效果，一套加装了闪光灯和人像镜头的专业相机还是需要的。不过由于这套器材过于专业，需要额外花时间学习调试，因此也惹出过一些麻烦。</p><p>比如前不久，我和模特下班后去照圣诞节装饰的彩灯。大家都知道这种相片应该怎么照，只要把模特摆在前面，背景是彩灯就可以了。许多人拿出手机之后就像这样咔咔照了，效果也不赖。但是使用专业器材的我，则需要经历一番调试过程才能开工：</p><ol><li>这台相机最常用的配置是光圈优先（A）模式，光圈调整到一个较大的值以提供良好的背景虚化。然后晚上增大曝光补偿，并开启闪光灯给近处的人物补光。快门摁下去，结果发现人照糊了。</li><li>问题在于晚上光线比较暗，相机不能准确测距，再加上大光圈导致景深很浅，人只要稍稍偏离焦点就会糊。于是我把光圈调小到 f/11 又试了几张。</li><li>现在整张照片变得清晰了，但背景有时特别亮，有时又特别暗。这次的问题是，闪光灯通过相机镜头测量环境光来决定功率，然而充满着彩灯的背景适用“测不准原理”，这时候需要手动指定功率。</li><li>最后我换到了手动（M）模式，固定快门时间为 1/60 秒，固定闪光灯功率为 1/16，终于照出了不输于别人用手机拍出的效果。</li></ol><p>不过这个时候的模特，已经冻成了一根冰棍，冷到做不出动作和表情了。</p><p>抛开这些因为不熟悉硬件设备而造成的麻烦，拍摄人像的本质，其实是一个 beautify 的过程，也就是照片中的人，应该要比现实中的人更好看一些。不过残酷的事实告诉我们，拍出 uglify 的照片要比 beautify 的照片容易太多了。要不然我也不会每次拍摄都必定听到下面的质问三连：</p><p align="center">    <strong>我有这么矮吗？</strong>    <strong>我的脸有这么大吗？？</strong>    <strong>我的脸有这么黑吗？？？</strong></p><p>从前，有女生为了了解直男的内心世界，下载了虎扑；如今，我为了能拍出 beautify 的照片，下载了小红书。小红书上有很多短视频讲人像摄影的技巧，比如应该把人放在哪里，人占的比例有多大，拿什么道具做什么姿势等等。虽然我心里比较抵制这类抖音式科普，但不得不承认它们还是蛮有用的。当然，即便是购入新型器材，运用摄影技巧，配合滤镜和补正，依然不能保证照片的质量。绝大部分的照片，在构图、表情、动作、服装、光线、背景中的某个细节总会有致命伤，这种情况是要作为废片处理的。能够维持五十度按下快门飞传一张到 Instagram 的出片率，就是我明年的目标了。</p><br /><h2 id="在家做饭"><a href="#在家做饭" class="headerlink" title="在家做饭"></a>在家做饭</h2><p>一个人生活和两个人生活的主要区别是，一个人生活很少自己做饭，但两个人生活则可以选择在家里做饭。这其中的原因是：做两人份食物花费的时间并不会比一人份食物长太多，也就是说，两个人生活时，做饭的平摊成本比较低。考虑到自己做饭比点外卖要健康，再加上不忍心浪费小可爱精湛的厨艺，我们大多数时间都在家里做饭。</p><p>我的厨艺基础不牢外加荒废多年，需要很多额外指导。刚开始，小可爱会演示做一道菜的过程，然后两天以后我再去重制这道菜。这样的效果并不太好，因为有时会忘记一些关键的步骤，比如腌制五花肉没有放淀粉，最后的口感会很不一样。后来我们尝试过角色扮演，她演大厨我演帮厨，大厨负责提示下一步操作，帮厨负责具体施工。这样的问题在于，帮厨并不太清楚几步之后会发生什么，食材下锅后会因为找不到调味料而手忙脚乱。到最后，我发现还是打开手机 APP 按照菜谱一步步做效果最好。</p><p>在我们制作过的诸多不同类型的菜肴中，最值得拿来炫耀的三种是煎牛排、清蒸鱼和盐酥鸡。</p><p>煎牛排想要做得好吃，有几个特别的要点。首先牛排在下锅之前要用锤子敲扁，其次锅中要倒入黄油而不是食用油，最后煎一些蒜末浇在牛排上面会更好吃。关于第一步我曾经有些困惑：在餐厅吃到的牛排有时候还挺厚的，是因为我们技术不行不能煎太厚的牛排，才需要用锤子敲扁么？后来我才知道，这一步的目的是把肉敲散，遇热收缩之后就不会变得很硬了。</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2019-12-29-2019-retrospect/steak.jpg"></div><p>清蒸鱼其实是一道没有什么难度的菜，前提是鱼买来的时候就已经处理干净了，否则在厨房还需要进行一些血腥的操作。这道菜我们不常做，主要因为它对食材的要求很高，不新鲜的鱼做出来会很难吃。</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2019-12-29-2019-retrospect/fish.jpg"></div><p>我们做的盐酥鸡更像是一道小吃。油炸本身没有什么难的，好吃与否的秘方全在于腌制。腌制过程涉及到的材料有好几种，而我从来都分不清楚淀粉、红薯粉、玉米淀粉和糯米淀粉之间的区别，所以腌制的过程只能由小可爱一人承担。刚炸完的盐酥鸡，无论是配番茄酱还是烧肉酱都非常好吃，不过一定要趁热吃完，再次加热的口感就没那么好了。</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2019-12-29-2019-retrospect/chicken.jpg"></div><p>虽然今年尝试做过不少菜肴，但离开了菜谱的指引还是无法独立动手。中餐存在着很多套路，一些特定的食材有特定的处理方法。现在通过制作不同的菜肴，我隐约发现了一些规律，但没有人指点说在某种情况下为什么要这么做，因此我也不敢在其他菜肴上贸然尝试。我想，或许学习一些有关烹饪的理论（即便它们都是从实践中总结出来的），会比通过实践积累经验进步更快吧。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;创业路上&quot;&gt;&lt;a href=&quot;#创业路上&quot; class=&quot;headerlink&quot; title=&quot;创业路上&quot;&gt;&lt;/a&gt;创业路上&lt;/h2&gt;&lt;p&gt;从 2017 年 2 月开始，我在 VMware 工作已经有近三年的时间了。前两年在平台组做了一系列项目，大部分和分布式系统治理有关。不能否认在那里学到了很多知识技能，但总有一天我会彻底厌倦看日志修 bug 的循环往复。2019 年 3 月，我换了一个组，投入到了新产品的开发工作中。&lt;/p&gt;
&lt;p&gt;进组的时机正逢项目从第一行代码起步。全组像一家创业公司：我们有大致的目标和方向，但所有的宏观设计和微观实现都需要自己摸索。与许多其他创业公司一样，踩各类知名开源软件的坑是大家都会经历的事情。&lt;/p&gt;
&lt;p&gt;我们的项目决定使用 &lt;a href=&quot;https://druid.apache.org/&quot; title=&quot;&quot; target=&quot;&quot;&gt;druid&lt;/a&gt; 作为时间序列数据库。新数据通过 &lt;a href=&quot;https://kafka.apache.org/&quot; title=&quot;&quot; target=&quot;&quot;&gt;kafka&lt;/a&gt; 源源不断进来，经索引后存放在数据库中，这一过程称为数据摄取。官网上的文档和例子还算齐全，示例程序运行起来也一切正常，但换成我们自己的数据后就立刻出现各类错误，以至于不得不深挖源码一探究竟。这么一个看似照葫芦画瓢的任务，最后花费了我三天时间。&lt;/p&gt;
&lt;p&gt;之后我们想比较两种不同的数据摄取方式，其中一种依赖于 twitter 某个 scala 开源库的两年前的代码。那些代码过于古老，存在一系列编译和运行的问题。每一次运行，我都觉得，这是最后一个错误，再过片刻就可以把程序跑通了。但每一次，又会出现新的错误。那些莫名其妙的异常信息迷惑着我，但我没有时间探索这个开源库的细枝末节，与其确切地知道为什么会出错，不如凭借直觉把解决的方法猜出来。经历近一星期的煎熬，我终于跑通了流水线，拿到了两种方案的对比结果。我们最后没有选择这套开源库，但我不认为这是一项做完即被丢弃和遗忘的工作。对创业公司而言，知道为什么某种方式不好，并且有理有据地避开它，可能会在未来节约不小的成本 [1]。&lt;/p&gt;
&lt;p&gt;从三月到九月，经历过一周连续五天的 war room，经历过打团战从上午十点到晚上九点半，经历过周六周日接连两天来公司点外卖，我们终于发布了产品的第一个版本。正当所有人想好好庆祝一下的时候，我们的客服电话被打爆了。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://bitmingw.com/categories/life/"/>
    
    
    <category term="memo" scheme="https://bitmingw.com/tags/memo/"/>
    
  </entry>
  
  <entry>
    <title>Changing the Default Program with update alternatives</title>
    <link href="https://bitmingw.com/2019/08/28/ubuntu-update-alternatives/"/>
    <id>https://bitmingw.com/2019/08/28/ubuntu-update-alternatives/</id>
    <published>2019-08-28T07:00:00.000Z</published>
    <updated>2019-08-28T02:35:28.653Z</updated>
    
    <content type="html"><![CDATA[<p>It is common to have multiple versions of the same software installed on a single ubuntu machine. With ubuntu&#39;s <code>update-alternatives</code> utility, it is easy to choose the default one to use.</p><span id="more"></span><p>For example, let&#39;s assume you have JDK 11 installed in the machine, and by default <code>java</code> points to JDK 11:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# java -version</span><br><span class="line">openjdk version &quot;11.0.3&quot; 2019-04-16</span><br><span class="line">OpenJDK Runtime Environment (build 11.0.3+7-Ubuntu-1ubuntu218.04.1)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 11.0.3+7-Ubuntu-1ubuntu218.04.1, mixed mode, sharing)</span><br></pre></td></tr></table></figure><p>Now you would like to work on a project that only supports JDK 8. After install JDK 8 with <code>apt-get install openjdk-8-jdk</code>, JDK 11 is still the default one. How can we make JDK 8 as the default?</p><p>Ubuntu keeps track of the default programs by maintaining a list of symbolic links, under <code>/etc/alternatives</code> directory. Each entry here is a shortcut points to the actual program, which may have more than one option (i.e. alternatives).</p><h2 id="List-All-Entries-of-Alternatives"><a href="#List-All-Entries-of-Alternatives" class="headerlink" title="List All Entries of Alternatives"></a>List All Entries of Alternatives</h2><p>To list all entries of alternatives in the system, use <code>update-alternatives --get-selections</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# update-alternatives --get-selections</span><br><span class="line">...</span><br><span class="line">java                           auto     &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-11-openjdk-amd64&#x2F;bin&#x2F;java</span><br><span class="line">javac                          auto     &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-11-openjdk-amd64&#x2F;bin&#x2F;javac</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>You can see <code>java</code> is pointing to actual program at <code>/usr/lib/jvm/java-11-openjdk-amd64/bin/java</code>, which belongs to JDK 11.</p><h2 id="List-All-Alternatives-of-an-Entry"><a href="#List-All-Alternatives-of-an-Entry" class="headerlink" title="List All Alternatives of an Entry"></a>List All Alternatives of an Entry</h2><p>To list all alternatives of <code>java</code>, use <code>update-alternatives --list java</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# update-alternatives --list java</span><br><span class="line">&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-11-openjdk-amd64&#x2F;bin&#x2F;java</span><br><span class="line">&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64&#x2F;jre&#x2F;bin&#x2F;java</span><br></pre></td></tr></table></figure><h2 id="Set-Alternatives-for-an-Entry"><a href="#Set-Alternatives-for-an-Entry" class="headerlink" title="Set Alternatives for an Entry"></a>Set Alternatives for an Entry</h2><p>To set <code>java</code> to use JDK 8 as the default, you can use an interactive command <code>update-alternatives --config java</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# update-alternatives --config java</span><br><span class="line">There are 2 choices for the alternative java (providing &#x2F;usr&#x2F;bin&#x2F;java).</span><br><span class="line"></span><br><span class="line">  Selection    Path                                            Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* 0            &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-11-openjdk-amd64&#x2F;bin&#x2F;java      1111      auto mode</span><br><span class="line">  1            &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-11-openjdk-amd64&#x2F;bin&#x2F;java      1111      manual mode</span><br><span class="line">  2            &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64&#x2F;jre&#x2F;bin&#x2F;java   1081      manual mode</span><br><span class="line"></span><br><span class="line">Press &lt;enter&gt; to keep the current choice[*], or type selection number: </span><br></pre></td></tr></table></figure><p>After typing selection number <code>2</code>, <code>update-alternatives</code> will modify the symbolic link to update the default java to use JDK 8.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Press &lt;enter&gt; to keep the current choice[*], or type selection number: 2</span><br><span class="line">update-alternatives: using &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64&#x2F;jre&#x2F;bin&#x2F;java to provide &#x2F;usr&#x2F;bin&#x2F;java (java) in manual mode</span><br><span class="line"></span><br><span class="line">root@ubuntu:~# java -version</span><br><span class="line">openjdk version &quot;1.8.0_212&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_212-8u212-b03-0ubuntu1.18.04.1-b03)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.212-b03, mixed mode)</span><br></pre></td></tr></table></figure><p>You can also do this in a script without interaction, if you know the full path of desired default program.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# update-alternatives --set java &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64&#x2F;jre&#x2F;bin&#x2F;java</span><br><span class="line">update-alternatives: using &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64&#x2F;jre&#x2F;bin&#x2F;java to provide &#x2F;usr&#x2F;bin&#x2F;java (java) in manual mode</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;It is common to have multiple versions of the same software installed on a single ubuntu machine. With ubuntu&amp;#39;s &lt;code&gt;update-alternatives&lt;/code&gt; utility, it is easy to choose the default one to use.&lt;/p&gt;</summary>
    
    
    
    <category term="tutorial" scheme="https://bitmingw.com/categories/tutorial/"/>
    
    
    <category term="Linux" scheme="https://bitmingw.com/tags/Linux/"/>
    
    <category term="ubuntu" scheme="https://bitmingw.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>简明易懂的量子计算</title>
    <link href="https://bitmingw.com/2019/06/09/easy-to-understand-quantum-computing/"/>
    <id>https://bitmingw.com/2019/06/09/easy-to-understand-quantum-computing/</id>
    <published>2019-06-09T07:00:00.000Z</published>
    <updated>2019-06-09T17:04:45.114Z</updated>
    
    <content type="html"><![CDATA[<p>1936 年，阿兰·图灵发表了图灵机理论，证明了存在一种计算机可以执行任何能被算法表达出来的计算过程。1945 年，第一台图灵完备的电子计算机 ENIAC 投入使用，它和后续的电子计算机改变了人类的历史进程。关于量子计算的研究始于 1980 年代。尽管时至今日，尚未出现能进行复杂计算的量子计算机，但量子计算的相关理论已经成熟。</p><p>一般来说，完成一次计算需要做三件事：</p><p><strong>提供输入 -&gt; 执行计算过程 -&gt; 提取输出</strong></p><p>对于电子计算机而言，输入和输出都可以表达为一串比特。计算过程，就是处理单元在程序的控制下，通过 AND, OR, NOT 等逻辑门电路修改这些比特的过程。</p><p>而量子计算机，输入的是量子比特（qubit）。计算过程是量子门（quantum logic gates）修改量子比特的状态（quantum state）。输出的是量子比特观测的结果。</p><p>因此，理解量子计算，需要搞清楚量子比特、量子门和量子观测。考虑到量子计算的物理实现有多种方法，且许多细节均为机密，本文只会阐释量子计算的理论基础。</p><span id="more"></span><br /><h2 id="量子比特"><a href="#量子比特" class="headerlink" title="量子比特"></a>量子比特</h2><p>传统的比特有且只有 0 和 1 两个状态。如果存在一个比特，那么它在某时刻的状态必须是 0 和 1 之间的一个。量子比特与传统的比特不同，它的状态在理论上用一个长度为 2 的列向量表示。首先我们定义如下两个量子比特 \(| 0 \rangle\) 和 \(| 1 \rangle\).</p><p>\[<br>| 0 \rangle = \left[<br>    \begin{array}{c}<br>    1 \\<br>    0 \end{array}<br>    \right]<br>\]</p><p>\[<br>| 1 \rangle = \left[<br>    \begin{array}{c}<br>    0 \\<br>    1 \end{array}<br>    \right]<br>\]</p><p>量子比特 \(| 0 \rangle\) 和 \(| 1 \rangle\) 是量子比特的计算基态（computational basis state）。或者说，它们是量子态空间的一组基。</p><p>任何一个量子比特 \(| e \rangle\) 都可以表达为 \(\alpha| 0 \rangle + \beta| 1 \rangle\) 的形式，其中 \(\alpha\) 和 \(\beta\) 是两个复数，且它们的模的平方和等于 1，也就是</p><p>\[<br>| \alpha |^2 + | \beta |^2 = 1<br>\]</p><p>上述的限制又称为<strong>归一化条件</strong>。</p><p>比如说，\(0.6 | 0 \rangle + 0.8 | 1 \rangle\) 是一个量子比特，\(\frac{1-i}{2} | 0 \rangle + \frac{1+i}{2} | 1 \rangle\) 也是一个量子比特，但 \((1-i) | 0 \rangle + (1+i) | 1 \rangle\) 就不是一个量子比特，因为它不满足归一化条件。按照数乘矩阵的规则，上面两个量子比特又可以写作</p><p>\[<br>\left[<br>\begin{array}{c}<br>0.6 \\<br>0.8 \end{array}<br>\right]<br>\]</p><p>和</p><p>\[<br>\left[<br>\begin{array}{c}<br>\frac{1-i}{2} \\<br>\frac{1+i}{2} \end{array}<br>\right]<br>\]</p><p>直观上讲，量子比特可以视为传统比特的一种叠加态（superposition）。比如说，\(0.6 | 0 \rangle + 0.8 | 1 \rangle\) 可以视为 0.36 (\(0.6^2\)) 个比特 0 和 0.64 (\(0.8^2\)) 个比特 1 的一种叠加状态。</p><br /><h2 id="量子门"><a href="#量子门" class="headerlink" title="量子门"></a>量子门</h2><p>正如数字电路中的逻辑门可以修改比特的状态一样，量子门可以修改量子比特的状态。量子门既可以只有一个输入和一个输出（转变单个量子的状态），也可以具有多个输入和多个输出（转变多个量子的状态）。输入和输出的数目应当相等，也就是说不可以吞噬量子。下面介绍两个单输入输出的量子门和一个多输入输出的量子门。</p><h3 id="NOT-门"><a href="#NOT-门" class="headerlink" title="NOT 门"></a>NOT 门</h3><p>NOT 门作用于单个量子比特，它可以交换两个基向量的系数：</p><p>\[<br>NOT(\alpha| 0 \rangle + \beta| 1 \rangle) = \alpha| 1 \rangle + \beta| 0 \rangle<br>\]</p><p>量子的 NOT 门是数字电路中 NOT 门的一个扩展。举一个直观的例子，假如原先的量子态是 0.36 个比特 0 和 0.64 个比特 1 的叠加态，那么经过 NOT 门之后，就变成了 0.64 个比特 0 和 0.36 个比特 1 的叠加态。</p><p>单输入输出的量子门可以使用一个 \(2 \times 2\) 的矩阵来表示。一个量子经过量子门之后的状态，由该量子状态向量<strong>左乘</strong>量子门矩阵的值决定。NOT 门对应的量子门矩阵为</p><p>\[<br>X = \left[<br>    \begin{array}{cc}<br>    0 &amp; 1 \\<br>    1 &amp; 0 \end{array}<br>    \right]<br>\]</p><p>因此，某个量子比特经过 NOT 门的结果为</p><p>\[<br>X \left[<br>\begin{array}{c}<br>\alpha \\<br>\beta \end{array}<br>\right]<br>=<br>\left[<br>\begin{array}{cc}<br>0 &amp; 1 \\<br>1 &amp; 0 \end{array}<br>\right]<br>\left[<br>\begin{array}{c}<br>\alpha \\<br>\beta \end{array}<br>\right]<br>=<br>\left[<br>\begin{array}{c}<br>\beta \\<br>\alpha \end{array}<br>\right]<br>\]</p><h3 id="Hadamard-门"><a href="#Hadamard-门" class="headerlink" title="Hadamard 门"></a>Hadamard 门</h3><p>Hadamard 门同样作用于单个量子比特，它可以依照系数分解现有的量子态：</p><p>\[<br>H(\alpha| 0 \rangle + \beta| 1 \rangle) = \frac{\alpha + \beta}{\sqrt{2}} | 0 \rangle + \frac{\alpha - \beta}{\sqrt{2}} | 1 \rangle<br>\]</p><p>用矩阵来表示就是</p><p>\[<br>H = \frac{\sqrt{2}}{2} \left[<br>\begin{array}{cc}<br>1 &amp;  1 \\<br>1 &amp; -1 \end{array}<br>\right]<br>\]</p><p>虽然 Hadamard 门和数字电路中的 AND 和 OR 门并无直接的关联，但它在不少量子计算算法中有重要的应用。有兴趣的读者可以自行证明，连续使用两次 Hadamard 门之后，量子会回到原先的状态——这个行为和 NOT 门是一致的。</p><p>单输入输出的量子门可以有无穷多种，只要满足量子比特状态向量左乘量子门矩阵的结果依然满足量子比特的归一化条件即可。在这里我们不加证明地给出如下定理：</p><blockquote><p>某个 \(2 \times 2\) 的复矩阵能作为量子门的一个表示，当且仅当其共轭矩阵等于其逆矩阵。</p></blockquote><h3 id="受控-NOT-门"><a href="#受控-NOT-门" class="headerlink" title="受控 NOT 门"></a>受控 NOT 门</h3><p>在计算机程序中，充满着条件判断语句：如果怎样，那么做什么，否则做别的什么。在量子计算中，我们也期望一个量子比特的状态可以因为另一个量子比特而改变，这就需要多输入输出的量子门。下面要介绍的是受控 NOT 门（CNOT 门）。它具有两个输入和两个输出。如果把输入和输出当作一个整体来看，这个状态可以用 \(\alpha| 00 \rangle + \beta| 01 \rangle + \gamma| 10 \rangle + \theta| 11 \rangle\) 来表示。其中 \(| 00 \rangle\), \(| 01 \rangle\), \(| 10 \rangle\), \(| 11 \rangle\) 是长度为 4 的列向量，它们由 \(| 0 \rangle\) 和 \(| 1 \rangle\) 拼接而成。</p><p>这个整体也需要满足归一化条件，即</p><p>\[<br>| \alpha |^2 + | \beta |^2 + | \gamma |^2 + | \theta |^2 = 1<br>\]</p><p>CNOT 门中，第一个输入是比特 0 的部分，会维持第二个输入的状态；而第一个输入是比特 1 的部分，会以 NOT 门的方式作用于第二个输入的状态。第一个输入的量子比特会原样输出，而第二个输入的量子比特的状态由上述的叠加态决定。用数学公式来表达就是</p><p>\[<br>CNOT(\alpha| 00 \rangle + \beta| 01 \rangle + \gamma| 10 \rangle + \theta| 11 \rangle) = \alpha| 00 \rangle + \beta| 01 \rangle + \gamma| 11 \rangle + \theta| 10 \rangle<br>\]</p><br /><h2 id="量子观测"><a href="#量子观测" class="headerlink" title="量子观测"></a>量子观测</h2><p>从上面关于量子门的介绍可以看到，一个量子比特处于两个量子态 \(| 0 \rangle\) 和 \(| 1 \rangle\) 的叠加态；两个量子比特组合成的整体，处于四个量子态 \(| 00 \rangle\), \(| 01 \rangle\), \(| 10 \rangle\) 和 \(| 11 \rangle\) 的叠加态。以此类推，\(n\) 个量子比特处于 \(2^n\) 个量子态的叠加态，这相对于 \(n\) 个传统的比特却只有一个固定的状态相比，是巨大的优势。然而物理定律也有它的限制——确切地知道一个量子比特的状态的方法是进行一次观测，但观测会使得叠加态坍缩，变成一个确定的状态。一个量子比特在观测之后得到的信息是传统的比特，它的值只能是 0 和 1 之间的一个。一个叠加态会塌缩成 0 或者 1，是由叠加态中的系数 \(\alpha\) 和 \(\beta\) 决定的。这个叠加态塌缩成 0 或 1 的概率分别为 \(| \alpha |^2\) 和 \(| \beta |^2\)。类似的，一个双量子比特的系统，其观测结果为 00, 01, 10, 11 的概率分别是 \(| \alpha |^2\), \(| \beta |^2\), \(| \gamma |^2\) 和 \(| \theta |^2\).</p><p>这样的物理定律导致量子计算的结果是不确定的，它有一定的概率输出一个错误的结果。在实际应用中需要额外的手段来验证输出的正确性。量子计算使用的算法，如果能在观测的上一步尽可能地减少量子比特的叠加态，就能以大概率得到正确的结果。</p><br /><h2 id="组合起来"><a href="#组合起来" class="headerlink" title="组合起来"></a>组合起来</h2><p>我们把上面提及的几个部分组合起来，所谓量子计算，无非就是：</p><ol><li>从一组计算基态开始（每个量子比特被初始化成 \(| 0 \rangle\) 或 \(| 1 \rangle\) 作为计算的输入）；</li><li>根据预定的算法，通过一系列量子门；</li><li>经过量子观测得到一串比特作为结果。</li></ol><p>值得说明的是，在现阶段，实现每一个量子门，都需要人工操纵物理实验设备，写量子计算的程序还远没有敲字符那么简单。</p><p>物理学家尚未证明量子计算的界限在哪里，不知道它是否可以用来模拟<strong>任何</strong>物理过程。从 1980 年代到现在，量子计算应用于实践似乎仍遥遥无期，但它的某些应用，如解算蛋白质结构，以及破解不对称加密密钥，已经引发了不少关注。我们无法知道它的大规模普及是否会像电子计算机一样再次改变人类社会。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1936 年，阿兰·图灵发表了图灵机理论，证明了存在一种计算机可以执行任何能被算法表达出来的计算过程。1945 年，第一台图灵完备的电子计算机 ENIAC 投入使用，它和后续的电子计算机改变了人类的历史进程。关于量子计算的研究始于 1980 年代。尽管时至今日，尚未出现能进行复杂计算的量子计算机，但量子计算的相关理论已经成熟。&lt;/p&gt;
&lt;p&gt;一般来说，完成一次计算需要做三件事：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提供输入 -&amp;gt; 执行计算过程 -&amp;gt; 提取输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于电子计算机而言，输入和输出都可以表达为一串比特。计算过程，就是处理单元在程序的控制下，通过 AND, OR, NOT 等逻辑门电路修改这些比特的过程。&lt;/p&gt;
&lt;p&gt;而量子计算机，输入的是量子比特（qubit）。计算过程是量子门（quantum logic gates）修改量子比特的状态（quantum state）。输出的是量子比特观测的结果。&lt;/p&gt;
&lt;p&gt;因此，理解量子计算，需要搞清楚量子比特、量子门和量子观测。考虑到量子计算的物理实现有多种方法，且许多细节均为机密，本文只会阐释量子计算的理论基础。&lt;/p&gt;</summary>
    
    
    
    <category term="tutorial" scheme="https://bitmingw.com/categories/tutorial/"/>
    
    
    <category term="quantum computing" scheme="https://bitmingw.com/tags/quantum-computing/"/>
    
  </entry>
  
  <entry>
    <title>相机的裁切系数</title>
    <link href="https://bitmingw.com/2019/03/31/camera-crop-factor/"/>
    <id>https://bitmingw.com/2019/03/31/camera-crop-factor/</id>
    <published>2019-03-31T07:00:00.000Z</published>
    <updated>2021-03-06T04:29:39.163Z</updated>
    
    <content type="html"><![CDATA[<p>尽管相机厂家为了推动低端单反/微单相机的销售，很少特意强调相机是全画幅还是残画幅，但我们并不能因此低估它的影响。</p><p>所谓相机的全画幅和残画幅，是指相机感光元件的大小。全画幅使用 36 x 24 mm 的传感器，常见的残画幅 APS-C 使用 23.6 x 15.7 mm （佳能是 22.2 x 14.8 mm）的传感器。全画幅与某种画幅的传感器的长度之比，称为裁切系数（crop factor）。很容易算出，全画幅的裁切系数为 1，普通 APS-C 画幅的裁切系数为 1.5，对于佳能来说这个值是 1.6。</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2019-03-31-camera-crop-factor/common-crop-factors.png">    <p>常用的相机画幅</p></div><p>知道裁切系数有什么用呢？由于画幅不同，为了取得相同的摄影效果，在不同相机上需要设定的焦距、光圈大小和感光度并不一样。有了裁切系数，我们就可以在不同画幅间进行转换：</p><blockquote><p>使用残画幅，在已知某张照片焦距、光圈大小和感光度的条件下，若改为全画幅相机，需使用的焦距、光圈大小和感光度。</p></blockquote><p>或者反过来：</p><blockquote><p>使用全画幅，在已知某张照片焦距、光圈大小和感光度的条件下，若改为残画幅相机，需使用的焦距、光圈大小和感光度。</p></blockquote><span id="more"></span><p>计算的公式是这样的：</p><p>\[<br>残画幅焦距 = \frac{全画幅焦距}{裁切系数}<br>\]</p><p>\[<br>残画幅光圈值 = \frac{全画幅光圈值}{裁切系数}<br>\]</p><p>\[<br>残画幅感光度 = \frac{全画幅感光度}{裁切系数^2}<br>\]</p><p>下面来举个例子。假设使用全画幅相机拍摄了一张人物肖像，焦距为 85 毫米，光圈值为 f/1.4，感光度为 100。请问使用尼康的 APS-C 画幅相机，为了达到相同的摄影效果，应该使用怎样的参数呢？</p><p>答案是，需要 55 毫米的焦距，f/0.9 的光圈，感光度为 45。</p><p>看到这里你可能笑了，上哪里去找符合这种要求的镜头呢？相机也不支持 50 以下的感光度吧？正是因为这样的镜头和相机不存在，所以全画幅和残画幅之间才形成了一条不可逾越的鸿沟：<strong>由于物理的限制，残画幅相机无法拍出全画幅相机的广角、大光圈、以及低感光度效果</strong>。我知道 APS-C 画幅的相机更加小巧，价格也更加便宜，但是考虑到未来对摄影的需要，还请下单之前考虑一下，你是否需要一台全画幅的相机？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;尽管相机厂家为了推动低端单反/微单相机的销售，很少特意强调相机是全画幅还是残画幅，但我们并不能因此低估它的影响。&lt;/p&gt;
&lt;p&gt;所谓相机的全画幅和残画幅，是指相机感光元件的大小。全画幅使用 36 x 24 mm 的传感器，常见的残画幅 APS-C 使用 23.6 x 15.7 mm （佳能是 22.2 x 14.8 mm）的传感器。全画幅与某种画幅的传感器的长度之比，称为裁切系数（crop factor）。很容易算出，全画幅的裁切系数为 1，普通 APS-C 画幅的裁切系数为 1.5，对于佳能来说这个值是 1.6。&lt;/p&gt;
&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;img src=&quot;https://bitmingw.com/assets/2019-03-31-camera-crop-factor/common-crop-factors.png&quot;&gt;
    &lt;p&gt;常用的相机画幅&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;知道裁切系数有什么用呢？由于画幅不同，为了取得相同的摄影效果，在不同相机上需要设定的焦距、光圈大小和感光度并不一样。有了裁切系数，我们就可以在不同画幅间进行转换：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用残画幅，在已知某张照片焦距、光圈大小和感光度的条件下，若改为全画幅相机，需使用的焦距、光圈大小和感光度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者反过来：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用全画幅，在已知某张照片焦距、光圈大小和感光度的条件下，若改为残画幅相机，需使用的焦距、光圈大小和感光度。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="info" scheme="https://bitmingw.com/categories/info/"/>
    
    
    <category term="photography" scheme="https://bitmingw.com/tags/photography/"/>
    
  </entry>
  
  <entry>
    <title>基督教的核心逻辑</title>
    <link href="https://bitmingw.com/2019/03/24/christian-core-logic/"/>
    <id>https://bitmingw.com/2019/03/24/christian-core-logic/</id>
    <published>2019-03-24T07:00:00.000Z</published>
    <updated>2019-03-25T04:54:32.183Z</updated>
    
    <content type="html"><![CDATA[<p>这周日，我被拉去本地某个基督教会听福音。传道者精心准备了演讲，在一个小时里把基督教的核心逻辑说清楚了。这篇文章我就加上自己的理解，以一位非信徒的身份转述一下。各位读者阅毕如果有兴趣，可以去教会聆听正宗的版本。</p><p>宗教可以认为是一种高度严密和仪式化的信仰。至于信仰，按照我的理解，便是那些无需证明就自动为真的命题。基督教作为一种宗教，它的信众会相信下面几个基本命题：</p><ol><li>世界上存在着一位神，他创造了万事万物。</li><li>神依照自己的形象创造了人。</li><li>所有人都是有罪的。</li><li>人在死后会经过审判，有罪的人会下地狱，无罪的人可以上天堂。</li><li>凡相信这位神和基督耶稣的存在，便会得到救赎，可在审判时洗刷一切罪过。</li></ol><p>这些命题都是无法证明的。传道者正确的做法，是通过举例，让听众觉得这些命题<strong>应当是真的</strong>。当听众不再质疑命题的真伪时，他们就完成了从福音听众到基督徒的转变。</p><p>下面我来逐条解释一下这几个命题。</p><span id="more"></span><p>首先，世上存在着一位神，他创造了万事万物。我想你肯定知道是人类的劳动制造出了你用的这部手机、你住的这幢房子，以及你生活中接触到的大多数生活用品。但是当你仰望天空的时候，是否想过，是谁创造了太阳、月亮、地球和满天繁星？有可能，这样一位创造者并不存在，但是人的心理会抗拒这样的答案，因为人相信凡事必有因果，我们的宇宙需要一个最初的因——宇宙是被一位全能且极富智慧的创造者设计出来的。这位创造者，我们尊称其为神。</p><p>人生活在地球上，与其他生物地位不同。狮子贵为百兽之王，充其量不过是动物园圈养的野兽，大象虽然能活两百年，但也逃脱不了被人骑的命运。既然狮子、大象和人拥有同样的造物主，那么一定是因为神的特殊安排——依照自己的形象创造了人——才使得人拥有了地球上独一无二的地位。</p><p>神依照自己的形象创造了人之后，同样以自己的德行要求人，无法达到要求的人会被神认为是有罪的。这是一种怎样的要求呢？粗略来说，任何不完美都是有罪的。并不是说，张华有罪，因为他在考试时作弊，而是，张华有罪，因为他在考试中未能获得满分。粗鲁的言行，嫉妒心，这都是神认为有罪的表现，因为这些行为缺损了神的荣耀——作为神的形象的化身，人是不应当做这些事情的。</p><p>基督教认为人死后有来世，而且在进入来世之前，每个人都会经历审判。所有有罪的人都会下地狱，与神永远地分别，而那些没有罪的人则可以上天堂，与神永存。按照上一段所述，所有人都是有罪的，因此所有人都会下地狱，这个结局太惨了，于是需要修改游戏规则，让一部分人可以上天堂。</p><p>这类规则可能有很多种。它可以是非常简单的，比如随机掷骰子，谁是六点谁上天堂；也可以是非常不公平的，比如财富大于一百万美元的可以去天堂；或者是看上去很美好但是很难衡量的，比如做的善事比恶事多的人可以进天堂。神想了一个更聪明的办法，他派自己的儿子基督耶稣来到人间。耶稣被钉到了十字架上，流血而死。耶稣以自己的牺牲，代替了人犯下种种罪行所应受的惩罚，使人可以上天堂与神同在。而这一切的前提，是人虔诚地相信神和基督耶稣的故事。</p><p>综上所述，基督教告诉人们一个简单的道理（即“福音”）：要想死后进天堂，信基督是唯一的途径。众多的基督徒出于善意和怜悯之心，不愿看到亲人和朋友最后下地狱，因此会向他们传播福音。现代的基督教正是这样发展壮大的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这周日，我被拉去本地某个基督教会听福音。传道者精心准备了演讲，在一个小时里把基督教的核心逻辑说清楚了。这篇文章我就加上自己的理解，以一位非信徒的身份转述一下。各位读者阅毕如果有兴趣，可以去教会聆听正宗的版本。&lt;/p&gt;
&lt;p&gt;宗教可以认为是一种高度严密和仪式化的信仰。至于信仰，按照我的理解，便是那些无需证明就自动为真的命题。基督教作为一种宗教，它的信众会相信下面几个基本命题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;世界上存在着一位神，他创造了万事万物。&lt;/li&gt;
&lt;li&gt;神依照自己的形象创造了人。&lt;/li&gt;
&lt;li&gt;所有人都是有罪的。&lt;/li&gt;
&lt;li&gt;人在死后会经过审判，有罪的人会下地狱，无罪的人可以上天堂。&lt;/li&gt;
&lt;li&gt;凡相信这位神和基督耶稣的存在，便会得到救赎，可在审判时洗刷一切罪过。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些命题都是无法证明的。传道者正确的做法，是通过举例，让听众觉得这些命题&lt;strong&gt;应当是真的&lt;/strong&gt;。当听众不再质疑命题的真伪时，他们就完成了从福音听众到基督徒的转变。&lt;/p&gt;
&lt;p&gt;下面我来逐条解释一下这几个命题。&lt;/p&gt;</summary>
    
    
    
    <category term="idea" scheme="https://bitmingw.com/categories/idea/"/>
    
    
    <category term="religion" scheme="https://bitmingw.com/tags/religion/"/>
    
  </entry>
  
  <entry>
    <title>《心理测量者》：有关正义、理想社会与人生信念</title>
    <link href="https://bitmingw.com/2019/02/18/psycho-pass/"/>
    <id>https://bitmingw.com/2019/02/18/psycho-pass/</id>
    <published>2019-02-18T08:00:00.000Z</published>
    <updated>2019-02-19T02:33:50.853Z</updated>
    
    <content type="html"><![CDATA[<p>在热血的战斗场面从脑海中逐渐消退之后，《心理测量者》留下的，是虚渊玄对正义、理想社会与人生信念的诸多思考。</p><p>在这样一个架空的世界里，西比拉系统（Sibyl System）通过测量人的犯罪系数来预测犯罪行为，并允许刑警对犯罪系数高的人实施惩戒。在这个世界，何为正义，是由西比拉决定的。那么正义到底是什么呢？正义与非正义又是如何界定的呢？假设火车会轧死铁轨上的五个孩子，但是你只要把一个胖子从桥上推下去就能救那五个孩子的命，这种行为是正义的么？因为判定正义，是西比拉拥有的特权，所以西比拉可以使用任何逻辑上自洽的判断标准。比如说，比起不作为，把胖子推到桥下的人拥有更高的犯罪系数，因此用一个胖子的命救五个孩子的命是非正义的。更广义的说，正义与非正义并不存在一个绝对的界定，它只要能被普罗大众接受即可。</p><span id="more"></span><br /><p>《心理测量值》剧情的真正转折点是常守朱监视官意识到了免罪体质者的存在——这类特殊的人可以通过意念操控自己的犯罪系数，是西比拉系统无法解决的漏洞之一。由于社会的和平安宁完全依赖于西比拉的正确运转，如果这些无法处理的情形被公之于众，无疑会极大地动摇统治根基。西比拉既然以伟大、光荣、正确来标榜自己，也就意味着从外界看来，它必须是完美无缺的，不能做出任何错误的决定。而一旦它的错误或者过失被广而告之，从未怀疑过它的臣民们就会陷入混乱之中，这也是西比拉要竭尽全力隐藏免罪体质者的原因。假如西比拉对外的宣传没有那么完美——它仅仅是一个参考，不应作为安保和惩戒的唯一依据——那么臣民们就会发展出一套自己的应对策略。大厦即将倾覆之时，也就不会是一片残垣断瓦的景象了。</p><p>即便西比拉系统是完美的，它可以精确测量每个人的犯罪系数，使得免罪体质者无法逍遥法外，那么是否可以裁撤掉公安局的刑警队，改为全部使用自动系统（drone）上街巡逻，抓捕或击杀犯罪系数过高的人呢？很可惜，答案依然是否定的。维护治安和控制犯罪的工作是在和人打交道，让刑警拿着 dominator 来处置罪犯，就默许了执行者对此种场景可以有自己的理解和判断，把最后对人的处置权交给了人类自己。可能是出于便于追责的原因，我们总是需要一个负责人，而不是一台负责机器，或者一套负责算法。机器和算法是没有能力负责的，只有人才可以，这也算得上是人的特权了。</p><p>未来的理想社会是怎样的呢？是剧情中那种矛盾最小化的社会么？这样的社会通过监控犯罪系数，在犯罪发生之前就予以消灭，以维持和谐的形象。但是，这种做法其实有极大的危害。</p><p>这是因为，监控并非全知全能，世界上总会存在监控无法覆盖的地方。这里既包括出于安全考虑而故意屏蔽网络信号的无人机装配工厂，也有由于历史原因遗留的废弃地下空间，当然也不可能在每家每户安装闭路影像。这些角落，依旧可以不受监控地实施各种犯罪行为。监控把这个社会隔离开来，变成一个明社会和一个暗社会。在明社会里，一切看上去都是和谐安宁的景象。居民可以安心在公园里散步，在商城里购物，在街边的咖啡厅闲聊，丝毫不需担心扒手盗走钱包，或者飞车贼拦路抢劫。但是在暗社会里，人们因为过高的犯罪系数无法进入明社会，因为他们会被立即带走接受“治疗”。被束缚了自由的暗社会居民，从此只能在暗社会出没。受束缚和压抑的时间越久，心灵的面目就变得越发狰狞。因此，这种矛盾最小化的社会并没有最小化整体的矛盾，而只是最小化了某些地区的矛盾，也就是把矛盾从一些地方转移到了另一些地方。明社会的居民长期没有得到磨练，已经完全不知如何处置身旁的犯罪时，监控系统的一次失灵，就能引发一场整个暗社会对明社会的吞噬。</p><br /><p>本剧的大反派槙岛圣护是一个很厉害的人，他兼具免罪体质和领导才华。他幼年时与同龄人格格不入的创伤，与他成年之后对人性孜孜不倦的探求（多是引诱和观察他人犯罪），催生出他对西比拉的厌恶。关于这样一个人，我既有欣赏的一面，也有鄙视的一面。</p><p>我欣赏他不被强权收买的态度。在被捕之后，西比拉想要招安他。这看上去是一个双赢的局面：西比拉的运作需要思维特立独行的人，而圣护也可以借此获得读取每个人意志的机会，成为神明一样的存在。然而看到了西比拉系统真相的圣护拒绝了这次机会，开始了逃亡之旅。圣护崇尚的信念，是鼓励每个人自己做出选择，自己承担风险，自己寻求刺激，而不是由一个体制去安排每个人的生活。如果为西比拉工作，无疑是背弃信念，开始对千千万万人的生活指手画脚。他知道蓝色药丸通往着无上的权威，而红色药丸终究难逃一死，但也几乎没有犹豫地拿走了红色药丸。</p><p>同时，我鄙视他不顾后果的破坏行动。只能破坏体制却无力构建体制的人，是无耻的。圣护认为西比拉系统不应该存在，犯罪系数是整个社会的枷锁，他想要通过制造饥荒这样的激进措施去破坏体制。但是，他也从来没有说过没有西比拉的世界会是什么样子。人们确实获取了宝贵的自由，但是然后呢？是谁通过什么重新建立起社会必要的秩序呢？这些后续，他怕是没有想过，可能也不太关心。虽然，在前一个体制倒下之后，下一个未经设计的体制会自然涌现出来，但是历史告诉我们，这样的体制往往会比那个已经倒塌的体制更差。同样是获知了西比拉系统的真相，常守朱监视官的表现就成熟得多：她在感性上极为厌恶，却又在理性上无比赞同。我想她可能是意识到了，现阶段没有什么比西比拉系统更完备的方法来管理整个社会吧。</p><p>此刻，我无从知道，对常守朱而言，西比拉的存在是否已经成为了她信念的一部分。西比拉有存在的理由，也有不应存在的理由。当它的存在或者不应存在，变成了信念的一部分，性质就发生了变化。所有的有利证据会得到强化，所有的不利证据会被大脑销毁。信念是不需要证明的，恰恰想法，它是公理，用来指导其他的证明。正因为信念有太过重要的意义，它也理所应当成为了体制重点管控的对象。如同政府会向宪法学教授灌输课堂应当宣扬本国政治制度的信念一样，西比拉系统也会尽力诱导常守朱去相信它是社会统治不可或缺的一部分。但是站在个人的角度，由于信念的存在会阻碍理性的思考，所以尽量少地持有信念才是明智的选择。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在热血的战斗场面从脑海中逐渐消退之后，《心理测量者》留下的，是虚渊玄对正义、理想社会与人生信念的诸多思考。&lt;/p&gt;
&lt;p&gt;在这样一个架空的世界里，西比拉系统（Sibyl System）通过测量人的犯罪系数来预测犯罪行为，并允许刑警对犯罪系数高的人实施惩戒。在这个世界，何为正义，是由西比拉决定的。那么正义到底是什么呢？正义与非正义又是如何界定的呢？假设火车会轧死铁轨上的五个孩子，但是你只要把一个胖子从桥上推下去就能救那五个孩子的命，这种行为是正义的么？因为判定正义，是西比拉拥有的特权，所以西比拉可以使用任何逻辑上自洽的判断标准。比如说，比起不作为，把胖子推到桥下的人拥有更高的犯罪系数，因此用一个胖子的命救五个孩子的命是非正义的。更广义的说，正义与非正义并不存在一个绝对的界定，它只要能被普罗大众接受即可。&lt;/p&gt;</summary>
    
    
    
    <category term="idea" scheme="https://bitmingw.com/categories/idea/"/>
    
    
    <category term="discussion" scheme="https://bitmingw.com/tags/discussion/"/>
    
  </entry>
  
  <entry>
    <title>多做设计 少写代码</title>
    <link href="https://bitmingw.com/2019/02/04/design-more-write-less/"/>
    <id>https://bitmingw.com/2019/02/04/design-more-write-less/</id>
    <published>2019-02-04T08:00:00.000Z</published>
    <updated>2019-02-05T06:42:57.111Z</updated>
    
    <content type="html"><![CDATA[<p>一线的程序员可能会遇到这种事情：领导安排一个任务，按照自己的能力两个小时就可以做完，但领导偏偏要你用半个小时设计，然后花三个小时给同事讲怎么做，同事做完之后又用半个小时评审，最后觉得还不如自己一个人做得好。既然如此，为什么要把任务交给别人去做呢？</p><span id="more"></span><p>因为，设计和实现的信息密度是不一样的，这两种工作的含金量是有差别的。</p><p>具体的代码实现属于密度低的信息：实现中有很多细节的魔鬼，与软件的功能并无太大关系，比如为了多线程协调工作而引入某种同步机制。软件的功能设计则属于密度高的信息：你可以用几张图清楚地表达出某个功能的作用原理，却不需要花好多个小时研读它背后的代码。功能设计是代码实现的抽象，正因为它，信息得到了提炼，含金量也因此提高。</p><p>从职业发展的角度来讲，程序员无论是成长为技术骨干，还是转型做项目经理，都需要在公司建立越来越大的影响力。影响力在很大程度上是与规模等价的——你带领或者管理的软件规模越大，你的影响力就越大。既然如此，就更应当把精力集中到信息密度更高的地方。当你站到了更高的抽象层次上，大脑会允许你处理更大规模的业务，这就是职业发展迈向下一个台阶的起点。</p><p>回到上文提出的例子，自己两个小时的工作比用四个小时教别人工作的效果要好，那为什么还要把任务交给别人来做呢？这是因为，代码并不是写完就万事大吉了，它会不断地被人阅读，被人提问，被人修改。程序员在维护一段代码上花费的时间，会远远超过编写它的时间。你编写并维护这段代码，就意味着今后你需要长期在大脑中存储和运算这些密度较低的信息——具体实现的细节。这些信息会与你的设计工作抢占资源，损耗精力，阻碍你获取更大的影响力。</p><p>综上所述，如果有条件，程序员应当多多参与设计工作，同时适当把具体的编码活动外包出去。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一线的程序员可能会遇到这种事情：领导安排一个任务，按照自己的能力两个小时就可以做完，但领导偏偏要你用半个小时设计，然后花三个小时给同事讲怎么做，同事做完之后又用半个小时评审，最后觉得还不如自己一个人做得好。既然如此，为什么要把任务交给别人去做呢？&lt;/p&gt;</summary>
    
    
    
    <category term="idea" scheme="https://bitmingw.com/categories/idea/"/>
    
    
    <category term="programming" scheme="https://bitmingw.com/tags/programming/"/>
    
    <category term="discussion" scheme="https://bitmingw.com/tags/discussion/"/>
    
    <category term="management" scheme="https://bitmingw.com/tags/management/"/>
    
  </entry>
  
  <entry>
    <title>为什么我的照片是模糊的</title>
    <link href="https://bitmingw.com/2019/02/03/why-my-photo-is-blurred/"/>
    <id>https://bitmingw.com/2019/02/03/why-my-photo-is-blurred/</id>
    <published>2019-02-03T08:00:00.000Z</published>
    <updated>2019-02-03T21:35:32.631Z</updated>
    
    <content type="html"><![CDATA[<p>去年用微单相机开始摄影以来，我时不时会遇到一个怪现象：一张照片乍看起来很好，但稍稍放大就会发现画面是模糊的。这样的照片，即便构图很好、人照得很精致、色彩也很有吸引力，依旧只能算作废品。在拍过好几个月的照片之后，我终于搞清楚了这背后的原因。</p><span id="more"></span><p>判断一张照片的好坏，最基本的维度是曝光。如果照片过亮或是过暗，以至于被拍摄的对象看不清楚，是几乎不可能成为一张好照片的。从相机的角度出发，控制曝光的手段只有三个：快门速度、光圈大小、感光度。快门速度越快、光圈越小、感光度越低，则曝光水平越低；反之，快门速度越慢、光圈越大、感光度越高，则曝光水平越高。</p><p>在自动模式（AUTO）下，相机会根据被拍摄的物体自动选择快门速度、光圈大小和感光度。我开始学习摄影的时候，听说大多数场景应当使用光圈优先模式（A），因此我就跳过自动模式，直接从光圈优先模式起步了。这种模式理论上讲是由摄影师来控制光圈的大小，然后相机根据曝光的需要自动选取快门速度和感光度。不过可能是因为我某天手滑取消了自动感光度，用一个较低的固定值 100 代替，所以相机真正能调整的就只剩下快门速度了。在快门速度低于 1/30 秒的时候，即便有光学防抖，放大后的照片也会变成模糊的影像。</p><p>在光线昏暗的地方更容易出现照片模糊的问题，对付它的方法有如下几种：</p><p>首先，强烈建议开启自动感光度。你可以为自动感光度设置一个合理的上界，比如 3200 或者 6400，这样噪点不至于非常难看。</p><p>第二，增大光圈，让更多的光可以进入镜头。在预览时可以看到相机选定的快门速度，这个值不能大于 1/30 秒，最好不大于 1/60 秒。更高的快门速度可以消除手抖对照片的影响。如果最大的光圈依然无法满足需要，你可能需要一个光圈更大的镜头，或者使用闪光灯等方式提供额外的照明。</p><p>最后，使用三脚架可以彻底解决静止物体的模糊问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;去年用微单相机开始摄影以来，我时不时会遇到一个怪现象：一张照片乍看起来很好，但稍稍放大就会发现画面是模糊的。这样的照片，即便构图很好、人照得很精致、色彩也很有吸引力，依旧只能算作废品。在拍过好几个月的照片之后，我终于搞清楚了这背后的原因。&lt;/p&gt;</summary>
    
    
    
    <category term="info" scheme="https://bitmingw.com/categories/info/"/>
    
    
    <category term="photography" scheme="https://bitmingw.com/tags/photography/"/>
    
  </entry>
  
  <entry>
    <title>2019 年的一些计划</title>
    <link href="https://bitmingw.com/2019/01/01/2019-plan/"/>
    <id>https://bitmingw.com/2019/01/01/2019-plan/</id>
    <published>2019-01-01T08:00:00.000Z</published>
    <updated>2019-01-01T21:19:08.951Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，从学校毕业已经有两年的时间了，我也终于成长为一个稍有经验的社会人。翻看到两年前写的 <a href="https://bitmingw.com/2017/01/01/2017-plan/" title="" target="">《2017 年度规划》</a>，其中既有顺利完成并一直坚持下来的部分，也有半途而废石沉大海的部分。两年之后，我想把自己对 2019 年的一些想法发表出来，以便让多年之后的我能回忆起今天在思考着什么。</p><span id="more"></span><br /><h2 id="关心身边的人"><a href="#关心身边的人" class="headerlink" title="关心身边的人"></a>关心身边的人</h2><p>在同龄人中，我可能算是不太爱社交的类型。不会积极主动找人聊天，不太容易体察到别人的需要。虽然学会了优雅地独处，一个人的时光不会太难过，但是那些真正让我印象深刻的片段，依旧是和朋友们、和亲人们，在一起玩耍、在一起工作、在一起生活的日子。</p><p>2019 年，我会花更多的时间关心和陪伴身边的人。彼此交换最新的信息，分享喜悦，分担忧伤。我会更积极地投身到有益的社交中去，与喜爱的人创造更多的回忆。</p><br /><h2 id="长途旅行"><a href="#长途旅行" class="headerlink" title="长途旅行"></a>长途旅行</h2><p>2017 年的我去过了美国的很多地方，但是 2018 年游历的地方就没有那么多了。希望 2019 年的我参与几次长途旅行，哪怕是大峡谷、羚羊谷和黄石公园这种身边人都早已去过的地方。</p><br /><h2 id="研究摄影"><a href="#研究摄影" class="headerlink" title="研究摄影"></a>研究摄影</h2><p>去年为了波多黎各的行程，我买了微单相机。这款相机的使用率并不太高，一方面可能是因为出门较少，另一方面也是由于摄影技术不佳。2019 年我会花些时间研究摄影，让相机为我的生活留下更多彩的回忆。在此要提前感谢会成为模特的人：学习摄影是以大量废品作为代价的，到时候还请多多包涵。</p><br /><h2 id="学习烹饪"><a href="#学习烹饪" class="headerlink" title="学习烹饪"></a>学习烹饪</h2><p>我最早开始做饭是在佐治亚理工读书的时候。从那时到现在，烹饪的技术一直都没有太大的进步，仅仅维持在“能吃”的水平。考虑到自己不可能一辈子在外面吃饭，而且女孩子也比较喜欢会做饭的男生，我需要认真学习烹饪了。初步的打算是，如果周末在家，那就自己做饭吃。从菜谱开始一点点学起，时间长了总会有进步的。</p><br /><h2 id="解读一款知名开源软件"><a href="#解读一款知名开源软件" class="headerlink" title="解读一款知名开源软件"></a>解读一款知名开源软件</h2><p>既然决定把成为架构师作为职业理想，那么就应该为此付诸行动。架构师了解很多既有的优秀软件的设计，而这些设计通常可以通过研究知名开源软件而心领神会。2019 年我将开始第一款开源软件的解剖工作，它大概率会是 netty 和 kafka 中的一个。我会在博客中持续披露我的最新发现。</p><br /><h2 id="上一门公开课"><a href="#上一门公开课" class="headerlink" title="上一门公开课"></a>上一门公开课</h2><p>本科的时候，我算得上是一个公开课狂人了。后来，随着时间越发紧张，上公开课的事情渐渐搁置了下来。不过今年，我还是打算认认真真地把 <a href="https://pdos.csail.mit.edu/6.824/index.html" title="" target="">MIT 6.824 Distributed Systems</a> 这门课上完，包括提交课程要求的所有作业。这是我今年关于公开课的唯一的计划——正因为这门课对职业发展如此重要，所以才能享受到特别的待遇。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知不觉，从学校毕业已经有两年的时间了，我也终于成长为一个稍有经验的社会人。翻看到两年前写的 &lt;a href=&quot;https://bitmingw.com/2017/01/01/2017-plan/&quot; title=&quot;&quot; target=&quot;&quot;&gt;《2017 年度规划》&lt;/a&gt;，其中既有顺利完成并一直坚持下来的部分，也有半途而废石沉大海的部分。两年之后，我想把自己对 2019 年的一些想法发表出来，以便让多年之后的我能回忆起今天在思考着什么。&lt;/p&gt;</summary>
    
    
    
    <category term="plan" scheme="https://bitmingw.com/categories/plan/"/>
    
    
    <category term="planning" scheme="https://bitmingw.com/tags/planning/"/>
    
  </entry>
  
  <entry>
    <title>2018 年终总结</title>
    <link href="https://bitmingw.com/2018/12/30/2018-retrospect/"/>
    <id>https://bitmingw.com/2018/12/30/2018-retrospect/</id>
    <published>2018-12-30T08:00:00.000Z</published>
    <updated>2021-03-06T04:29:15.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="晨练的体验"><a href="#晨练的体验" class="headerlink" title="晨练的体验"></a>晨练的体验</h2><p>去年年中在三藩市区跑过五公里，年底又在伯克利跑了万米，今年轮到半程马拉松了。为了避免中途被救护车敲诈钱财，我预先找了健身教练破财免灾。第一次的训练结束之后，身体伤得不轻，有三四天时间腹部动弹不得，在床上无法坐起来，只能翻滚着下去。第二次训练也没好到哪里去，在回家的路上，因为腿已失去知觉，踩油门和刹车的力度都把握不住了，几分钟的路程还要胆战心惊地把车开回家。周一在公司被经理叫去谈话的时候，我不得不靠着椅子站立，因为“坐下之后就站不起来了”。这种残障人的生活状态，在训练三四次之后才渐渐好转。</p><span id="more"></span><p>跟欧洲哥相比，我的教练已经算非常仁慈了。欧洲哥是健身房里的人气教练，他大多数时间都在与各种女学员打交道。外表看上去，他是一个温文尔雅的绅士，但他的训练却格外严厉。欧洲哥有没有在工作，只需要听健身房里有没有凄凌的叫声就知道了。如果说人生中的不幸是颜值不够高，那么不幸中的万幸就是没有被欧洲哥盯上。</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2018-12-30-2018-retrospect/SF-marathon.jpg">    <p>马拉松行进途中</p></div><p>跑半程马拉松的当日，我时不时地低头看手表来确认现在的速度。穿过了漫长的海岸线，经历了金门大桥半英里长的大上坡，在城市的宽阔街道间游走，当我满怀信心觉得两个小时之内肯定可以抵达终点的时候，腿脚忽然就开始不听使唤了。左腿的膝盖和右脚的脚踝，跑一步疼一下，使我不得不走着穿过终点线。没能一口气跑完全程，还是有些遗憾的。</p><br /><h2 id="夜校的体验"><a href="#夜校的体验" class="headerlink" title="夜校的体验"></a>夜校的体验</h2><p>湾区的娱乐资源非常贫瘠，以至于我们组竟然想出了周六来公司打（xiu）球（bug）的活动。如果下班不是特别晚，我倒是诚心诚意地推荐在晚上报个什么课程。今年我一共上了两门课，分别是乒乓球和日本语。</p><p>上乒乓球课是因为晚上回家前和同事一起打球，发现自己与对方大概差了二十个段位。为了与同事对战时不至于让对方非常无聊，我决心认真学习这项国人技能。参加了两个月的培训班后，我发现乒乓球是一项非常依赖预判的运动。乒乓的球速很快，确定下一个动作，以怎样的方位和力量回球，在球刚刚离开对手的拍子时就需要想好了。依靠大脑的逻辑思维是来不及的，所有的动作都要演变成身体的本能反应才可以。这种本能反应，是建立在每小时上千个球，持续不断的训练之上的。为了把差距缩小到十九个段位，我还有漫长的路要走啊。</p><p>我找的这门 <a href="https://www.usajapan.org/language/group/" title="" target="">日语课程</a> 真的很良心，三个月二十四小时收费不到三百，而且因为是超小班教学（可能因为没有多少学员），每个人一节课下来有很多次口语练习的机会。张口说话是很困难的事：如果只是心里想而不用嘴上说出来，例如轮到别人回答问题的时候，我往往能想出答案；但是轮到自己开口的时候，经常一下子就想不起来了！不过因为上课的同学都互相认识，老师也很鼓励大家，遇到这种场景还不至于特别尴尬，实在不行咱就拿英文说。</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2018-12-30-2018-retrospect/Morrison-Foerster.jpg">    <p>在豪华会议室上课</p></div><p>非常羡慕两位在苹果和甲骨文工作的同事，每年有公费去日本出差的机会。如果缺席了一两次课程，等下次他们回来的时候，就能拿到从日本带来的和果子——我们会一边分食一边讨论着岛国见闻。给我们上课的老太太非常的反传统。首先她不是一个注重妆容精致的人，每次上课都穿着松松垮垮的湾区限定免费服装，其次她在课堂上讨论的话题也时不时会跑偏。有次一个同学从日本回来，发生了类似于这样的对话：</p><blockquote><p>师：你在日本的时候，去过女仆咖啡厅么？<br>生：女仆咖啡厅没有去过，但是去过女仆酒吧。<br>师：女仆酒吧？很新奇哎！有照片么？<br>生：因为太害羞了，没有拍照。<br>师：好可惜啊！女仆可以帮你做什么吗？按摩什么的？<br>生：我不清楚……</p></blockquote><p>再比如，讲到日本少子化问题的时候，她会说：</p><blockquote><p>似乎日本政府对付少子化问题的方法是大力发展机器人。虽然机器人在老年人的家中普及还需要一段时间，但是有些人已经嗅到了其他的商机，比如 prostitution 可以比人类更便宜……</p></blockquote><p>这真的是太颠覆日本老太太在我心中的印象了 (&gt;_&lt;)</p><br /><h2 id="传道的体验"><a href="#传道的体验" class="headerlink" title="传道的体验"></a>传道的体验</h2><p>今年年初回国的时候，老师跟我说，国内的在线教育正处于一个高速发展的时期，无论是考试辅导还是职业培训，知识服务都有着巨大的需求。正巧友人 C 君在某医学院深造，想了解一下编程是怎么回事，因此我头脑一热决定开发一套零基础 Python 入门课程。</p><p>学习一门编程语言不是非常困难。和人类语言相比，编程语言的结构化更强，语法也更精炼。不过，如何用计算机的思维去描述现实世界的问题，是编程学习者很头疼的问题。</p><p>比如说判定一个字符串是否是回文，用计算机的思维去描述这件事，分这么几步：</p><ol><li>判断输入的字符串是否为一个空串。</li><li>创建两个指针变量，分别指向字符串的头和尾。</li><li>开始一个循环过程，如果两个被指向的字符不相等，返回“假”，否则向中间移动两个指针的位置。</li><li>如果直到两个指针相遇，都没有发现不相等的字符，返回“真”。</li></ol><p>一个熟练的程序员会觉得，判断回文这么简单的事情，完全没有必要拆成四步。但是可怜的友人 C 君，把第一步直接忽略，然后卡在了第二步——没有想到自己可以创建两个变量去追踪字符串的头和尾。没有想到可以创建新变量？这件事听起来似乎匪夷所思，但实际上又是在情理之中的。就像初中平面几何，如果老师没有讲过可以构造辅助线，你真的能想到这个题需要辅助线才能求解么？编程也是一样，初学者没有创建变量的意识，做过几次练习之后，才知道这种类型的问题可以通过构造指针变量求解。当判断回文的过程从四步缩减为一步的时候，就进入到了下一个层次的抽象。抽象的层次越高，能看到的世界就越广阔。关于程序员的打怪练级，大概就是这样一回事。</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2018-12-30-2018-retrospect/sample-python-questions.png">    <p>学习二十小时后的练习</p></div><p>除了要花很多时间解答奇奇怪怪的疑问，课程的编排也是让我伤透脑筋的地方。Python 编程涉及的基本概念很多，比如变量、数据类型、函数、关键字、缩进格式等等。不了解这些基本概念，就无法写出哪怕是非常基本的程序。我在课程刚开始的时候讲授了太多这些比较空虚的概念，却没有安排足量的练习，结果等到做 <code>list</code> 和 <code>dict</code> 的有关习题时，C 君不得不经常回去翻阅基本概念和语法。自己懂编程，和把编程教给别人，果真是两件完全不同的事情啊。</p><br /><h2 id="考试的体验"><a href="#考试的体验" class="headerlink" title="考试的体验"></a>考试的体验</h2><p>十二月初，我参加了日本语能力测试四级水平考试。与其说是四级，不如说是倒数四级——就是非常入门的意思。考试在三藩市某大学举行，考场是文科学部的普通教室，这种教室可以由国内常见的中小学教室经过缩小与旋转的线性变换得到。教室前方是门，最后有一排窗户，两侧是墙壁，放置着七行五列椅子。椅子右侧的扶手延伸出去变成了小桌板，勉强可以乘下一张答题卡。学生之间的距离是如此的紧凑，以至于我一抬眼就能看到三份答案，但是因为不了解彼此的水平，也不敢贸然参考。</p><p>做到听力部分的时候，我本以为教室会统一放广播，但令人大吃一惊的是，老师拿来了史前文物——录音机。试音时重复的那几句「いい天気だから、散歩しましょう！」（因为天气很好，去散步吧！），瞬间把我的思绪带回了初中英语课堂。受限于磁带这种介质，索尼牌录音机并不会比步步高有更好的表现，每道题开始之前的“咚”的一声充斥着黏浊的质感，好像音叉消散不去的余音。这萧索的墙壁，破败的桌椅，再加上索尼录音机，简直是没落资本主义国家的完美写照了。</p><p>听力的每道大题前都有一道例题。其中一个例题，我本来想选第二项，但是紧接着就听到了「一番いい者は3番ですから、答えはこの様に描きます。」（因为第三项是最佳选项，请像这样标记答案。），当场心态崩溃。考试能不能低分飘过，全看听力能做对多少了。</p><p>最让人无法理解的是，作为一个只需要填机读卡的考试，理论上讲当天就应该能出成绩了。但是，监考老师说，请大家明年二月去网站查分，这效率让我怀疑日本是否真的发生过工业革命。想来想去，我觉得日本语能力测试除了考试费用低廉之外，真的没有什么优点了。</p><br /><h2 id="解谜的体验"><a href="#解谜的体验" class="headerlink" title="解谜的体验"></a>解谜的体验</h2><p>程序员有两件不同的工作，一件是写 bug，一件是修 bug。经常会遇到的情况是，前人写完 bug 跑路了，后人不得不去修 bug。</p><p>修 bug 这件事和解谜非常类似。一开始拿到一个不透明的盒子，经过一些分析，然后跟别人解释这个盒子里有什么。如果拿到手的只有日志文件，用各类外部仪器测量就是主要的办法。把观察到的现象对照代码，重现执行链条，然后提出可能会出现问题的地方，再设计实验方案验证。如果能拿到手的是线上系统，那就可以使用一些交互式的手段了，比如晃动一下听声音，或者拿火烤一烤闻气味，实在不行把盒子炸开也是可以的，不过最后两种方式的成本就比较高了。</p><p>组里有个同事，最近半年和我一样，每天的工作就是玩解谜游戏。有一次他说，看了我的博客，觉得内容写得不错，但看不出我对什么样的技术真正感兴趣。我说自己也挺迷茫的，不像你现在就已经很明确自己要做什么了。然后他向我介绍了某高频交易基金通过用户态 TCP/IP 协议栈降低网络延迟的项目，又说，不要用战术上的勤奋去掩盖战略上的懒惰，修 bug 的时间长了就会忘记怎么写 bug，未来是属于写 bug 的，也是属于修 bug 的，但归根结底，还是属于写 bug 的。</p><p>是啊，我真的应该好好想一想，下一个要努力的方向了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;晨练的体验&quot;&gt;&lt;a href=&quot;#晨练的体验&quot; class=&quot;headerlink&quot; title=&quot;晨练的体验&quot;&gt;&lt;/a&gt;晨练的体验&lt;/h2&gt;&lt;p&gt;去年年中在三藩市区跑过五公里，年底又在伯克利跑了万米，今年轮到半程马拉松了。为了避免中途被救护车敲诈钱财，我预先找了健身教练破财免灾。第一次的训练结束之后，身体伤得不轻，有三四天时间腹部动弹不得，在床上无法坐起来，只能翻滚着下去。第二次训练也没好到哪里去，在回家的路上，因为腿已失去知觉，踩油门和刹车的力度都把握不住了，几分钟的路程还要胆战心惊地把车开回家。周一在公司被经理叫去谈话的时候，我不得不靠着椅子站立，因为“坐下之后就站不起来了”。这种残障人的生活状态，在训练三四次之后才渐渐好转。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://bitmingw.com/categories/life/"/>
    
    
    <category term="memo" scheme="https://bitmingw.com/tags/memo/"/>
    
  </entry>
  
  <entry>
    <title>十一招聘吐槽大会</title>
    <link href="https://bitmingw.com/2018/10/05/hiring-in-georgia-tech/"/>
    <id>https://bitmingw.com/2018/10/05/hiring-in-georgia-tech/</id>
    <published>2018-10-05T07:00:00.000Z</published>
    <updated>2021-03-06T04:29:03.102Z</updated>
    
    <content type="html"><![CDATA[<p>由于先前良好的运作，我被抽中在十一黄金周国庆假期去佐治亚理工（GT）参加 VMware 的校园招聘。</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2018-10-05-hiring-in-georgia-tech/tech-green.jpg"></div><p>国庆节当天是我们的首场活动。计算学院（CoC）的学生干部们在红楼里帮我们挤下了两张桌子。不知道这些学生干部是不是学校派来监视我们的间谍，他们每两个小时换一班岗，专职坐在旁边的桌子上刷手机。难道他们就这么闲不需要写作业么？还是在手机里装了 IDE 因此可以用手机写作业？</p><p>按照我们招聘经理的吩咐，所有收到的简历分成两堆，一堆是要拿回去的，另一堆是要交给环卫工人的。我们在桌子上摆了一左一右两个完全一样的文件夹，聊完之后会把简历放到其中一个文件夹里。可能每个学生都知道这两个文件夹意味着两种不同的结局，但可气的是他们就算眼睁睁地看着我把简历放进其中的一个，也无法知晓之后的命运。</p><span id="more"></span><p>我最怕过来面谈的学生说话嗓门很大，这样会打扰到旁边的人。同桌的三哥接待了一个迷之自信的中国人，把自己简历的每一行都大声描述了一遍。我从未见过在招聘会上如此健谈的国人，但可惜他耗尽了印度同事的耐心，壮烈牺牲。</p><p>在 GT，最容易遇到的专业背景，一种是搞机器学习的，一种是学信息安全的。他们的专业知识高深莫测，我很难听得懂。于是到了最后决定命运的关头，只能把有工作经历的人留下，把没有经历但可能很厉害的人请走。</p><p>来应聘的学生们问得最多的问题是，我是否应该在线申请。我的回答一律是，多个渠道多条路，你自己看着办。</p><p>我问他们最多的问题是，你在 VMware 打算做些什么。典型的回答有两种。一种是反问我，可以做些什么。还有一种会说，没关系，都行，都可以。虽然我讨厌这两种回答，但事实就是，咬定机器学习不放松的都被毙掉了。</p><p>前来排队的人一天都没有停歇过，四流水线全并行开工，五个小时收了一百多份简历。去掉了所有表现不佳、专业不匹配、以及没有大厂经历的人。另外选拔了若干高价值人才（HVT）在第二日开展一对一约谈。</p><p>第一天晚上举办了专场 tech talk。不知因为何种原因，一百人的教室只坐了二十人，食物浪费甚多。难道我们不幸与 due 撞车？？</p><p>正是因为大家对虚拟网络几乎一无所知，所以我吹 CorfuDB 这一波才会特别成功。台下鼓掌的人数和我巅峰时期的 bug 数差不多了，我很感动。</p><p>tech talk 的最后一个环节是抽奖。但这个奖不是抽出来的，而是由第一个关注我司 Instagram 并给管理员发私信的人获奖。一百多刀的智能音箱竟然是靠拼手速来决定花落谁家，这秒杀策略真的不是从淘宝那里学来的？</p><p>虽然晚上不再接收简历了，但我还是被一群陌生人围困并被迫交出了微信。</p><div style="text-align: center">    <img src="https://bitmingw.com/assets/2018-10-05-hiring-in-georgia-tech/piedmont-park.jpg"></div><p>第二天我们请来了那些 HVT 进行一对一的面谈。</p><p>在任何公司都见不到学校那么大的白板，这明明就是三面墙随便乱涂乱画啊。</p><p>虽然我们事先声称只是随便聊一聊，但那些按面试来准备的人都做对了。</p><p>之前经历很厉害，我又听得懂的人，不知不觉就聊到超时了。</p><p>之前经历很厉害，我却听不懂的人，就变成了，ta 在上面讲，我在下面听。</p><p>简历看上去很丰富，但是基本问题回答不清楚的人，很不幸死在了龙门之下。</p><p>五个人折腾了两天大概留下了二十份简历。拿到每份简历的成本是三百美元，但打印一张纸的成本只有几分钱。</p><p>然后这些厉害的人，通常都有不止一份 offer，会不会来很成问题。</p><p>对实习生来说，全职工作被其他厂家拐跑又占了多数。</p><p>于是我们折腾这么久估计也就能增添四五个新人吧。</p><p>最后的结论：和旧友一起吃饭，与陌生人在 tech rec 打保龄球，而不是招聘本身，才是此次行程最大的目的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于先前良好的运作，我被抽中在十一黄金周国庆假期去佐治亚理工（GT）参加 VMware 的校园招聘。&lt;/p&gt;
&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;img src=&quot;https://bitmingw.com/assets/2018-10-05-hiring-in-georgia-tech/tech-green.jpg&quot;&gt;
&lt;/div&gt;

&lt;p&gt;国庆节当天是我们的首场活动。计算学院（CoC）的学生干部们在红楼里帮我们挤下了两张桌子。不知道这些学生干部是不是学校派来监视我们的间谍，他们每两个小时换一班岗，专职坐在旁边的桌子上刷手机。难道他们就这么闲不需要写作业么？还是在手机里装了 IDE 因此可以用手机写作业？&lt;/p&gt;
&lt;p&gt;按照我们招聘经理的吩咐，所有收到的简历分成两堆，一堆是要拿回去的，另一堆是要交给环卫工人的。我们在桌子上摆了一左一右两个完全一样的文件夹，聊完之后会把简历放到其中一个文件夹里。可能每个学生都知道这两个文件夹意味着两种不同的结局，但可气的是他们就算眼睁睁地看着我把简历放进其中的一个，也无法知晓之后的命运。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://bitmingw.com/categories/life/"/>
    
    
    <category term="memo" scheme="https://bitmingw.com/tags/memo/"/>
    
  </entry>
  
  <entry>
    <title>git submodule 实用教程</title>
    <link href="https://bitmingw.com/2018/08/19/git-submodule-tutorial/"/>
    <id>https://bitmingw.com/2018/08/19/git-submodule-tutorial/</id>
    <published>2018-08-19T07:00:00.000Z</published>
    <updated>2018-08-20T01:35:15.326Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我们来讲解一下 <code>git submodule</code> 的实战用法，包括：</p><ol><li>注册 git 子模块</li><li>从已有的文件创建 git 子模块</li><li>向上同步主仓库</li><li>向下同步子模块仓库</li><li>疑难杂症</li></ol><span id="more"></span><br /><h2 id="注册-git-子模块"><a href="#注册-git-子模块" class="headerlink" title="注册 git 子模块"></a>注册 git 子模块</h2><p>假设我们有主仓库 <code>main-module.git</code>，远程地址 <code>https://github.com/bitmingw/main-module.git</code>，目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── main.txt</span><br></pre></td></tr></table></figure><p>以及仓库 <code>sub-module.git</code>，远程地址 <code>https://github.com/bitmingw/sub-module.git</code>，目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── sub.txt</span><br></pre></td></tr></table></figure><p>如果想要将仓库 <code>sub-module.git</code> 注册成为主仓库 <code>main-module.git</code> 的一个子模块，可以使用如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> main-module/</span></span><br><span class="line">git submodule add https://github.com/bitmingw/sub-module.git</span><br><span class="line">git commit -m &quot;add submodule version 1.0&quot;</span><br></pre></td></tr></table></figure><p>git 会自动从远程服务器 clone <code>sub-module.git</code>，之后 <code>main-module.git</code> 的目录会变成这个样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── main.txt</span><br><span class="line">└── sub-module</span><br><span class="line">    └── sub.txt</span><br></pre></td></tr></table></figure><p>由于添加 git 子模块的操作本身也是一个提交，因此它仅仅对 <code>main-module.git</code> 的当前分支有效，另外的分支不会感知到这一变化。</p><br /><h2 id="从已有的文件创建-git-子模块"><a href="#从已有的文件创建-git-子模块" class="headerlink" title="从已有的文件创建 git 子模块"></a>从已有的文件创建 git 子模块</h2><p>大多数时候，git 子模块不是凭空创建的，而是从项目中已有的文件拆分出来的。从已有的文件创建 git 子模块需要做三件事：首先为拆分出来的文件创建新的 git 仓库，然后从主仓库中将独立出去的文件移除，最后再注册 git 子模块。</p><p>例如，假设 <code>main-module.git</code> 的目录结构如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── main.txt</span><br><span class="line">└── sub-module</span><br><span class="line">    └── sub.txt</span><br></pre></td></tr></table></figure><p>它有 <code>v1.0</code> 和 <code>v2.0</code> 两个分支，在 <code>v2.0</code> 分支中，我们想让 <code>sub-module</code> 文件夹变成 <code>sub-module.git</code> 子模块。</p><p>第一步，为 <code>sub-module</code> 创建一个单独的 git 仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout v2.0</span><br><span class="line">cd sub-module</span><br><span class="line">git init</span><br><span class="line">git add sub.txt</span><br><span class="line">git commit -m &quot;version 1.0 of sub-module&quot;</span><br><span class="line">git remote add origin https://github.com/bitmingw/sub-module.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>第二步，从 <code>main-module.git</code> 中删除 <code>sub-module</code> 文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ..  # main-module/</span><br><span class="line">git rm -r sub-module</span><br><span class="line">git commit -m &quot;remove sub-module directory&quot;</span><br></pre></td></tr></table></figure><p>第三步，将 <code>sub-module.git</code> 注册为 <code>main-module.git</code> 的子模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> main-module/</span></span><br><span class="line">git submodule add https://github.com/bitmingw/sub-module.git</span><br><span class="line">git commit -m &quot;add submodule version 1.0&quot;</span><br></pre></td></tr></table></figure><br /><h2 id="向上同步主仓库"><a href="#向上同步主仓库" class="headerlink" title="向上同步主仓库"></a>向上同步主仓库</h2><p>如果你是子模块的开发者，当你希望主仓库使用新版本的子模块时，需要向上同步主仓库。</p><p>在主仓库中，可以使用 <code>git submodule status</code> 和 <code>git status</code> 查看子模块的状态。</p><p>如果主仓库使用的是最新版本的子模块，会显示如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;main-module$ git submodule status</span><br><span class="line"> 359bce6ea04c082229fb009013a4dd14c8af4f0c sub-module (heads&#x2F;master)</span><br><span class="line"></span><br><span class="line">~&#x2F;main-module$ git status</span><br><span class="line">On branch v2.0</span><br><span class="line">Your branch is up-to-date with &#39;origin&#x2F;v2.0</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>当子模块有未被使用的新提交时（例如在 <code>sub-module.git</code> 中执行 <code>git pull --rebase</code> 拉取新的内容后），git 会给予提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;main-module$ git submodule status</span><br><span class="line">+773275124c59b906da71e892b2f9d53c633bc252 sub-module (heads&#x2F;master)</span><br><span class="line"></span><br><span class="line">~&#x2F;main-module$ git status</span><br><span class="line">On branch v2.0</span><br><span class="line">Your branch is up-to-date with &#39;origin&#x2F;v2.0&#39;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   sub-module (new commits)</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>此时，如果想要将子模块的内容同步到主仓库，只需要在主仓库中创建一个新的提交即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> main-module/</span></span><br><span class="line">git add sub-module</span><br><span class="line">git commit -m &quot;use sub-module version 1.1&quot;</span><br></pre></td></tr></table></figure><br /><h2 id="向下同步子模块仓库"><a href="#向下同步子模块仓库" class="headerlink" title="向下同步子模块仓库"></a>向下同步子模块仓库</h2><p>如果你是主仓库的开发者，你可能不想使用最新版本的子模块，而是使用主仓库中指定版本的子模块，此时可以使用下面的指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update</span><br></pre></td></tr></table></figure><p>在使用该指令前，主仓库和子模块的 <code>git status</code> 分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;main-module$ git status</span><br><span class="line">On branch v2.0</span><br><span class="line">Your branch is up-to-date with &#39;origin&#x2F;v2.0&#39;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   sub-module (new commits)</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">~&#x2F;main-module&#x2F;sub-module$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#39;origin&#x2F;master&#39;.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>使用了 <code>git submodule update</code> 之后，两个仓库的 <code>git status</code> 信息变成了这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;main-module$ git status</span><br><span class="line">On branch v2.0</span><br><span class="line">Your branch is up-to-date with &#39;origin&#x2F;v2.0&#39;.</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">~&#x2F;main-module&#x2F;sub-module$ git status</span><br><span class="line">HEAD detached at 359bce6</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>这样，主仓库的开发者就可以从一个干净的空间开始工作了。</p><br /><h2 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h2><p>还记得我们是从 <code>v2.0</code> 分支引入子模块的么？假如现在要查看 <code>v1.0</code> 分支，会发生什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;main-module$ git checkout v1.0</span><br><span class="line">error: The following untracked working tree files would be overwritten by checkout:</span><br><span class="line">        sub-module&#x2F;sub.txt</span><br><span class="line">Please move or remove them before you can switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure><p>难道有了子模块之后我们就回不去了？？情况没有那么糟糕，我们可以通过 <code>git checkout -f v1.0</code> 强行回去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;main-module$ git checkout -f v1.0</span><br><span class="line">warning: unable to rmdir sub-module: Directory not empty</span><br><span class="line">Switched to branch &#39;v1.0&#39;</span><br><span class="line">Your branch is up-to-date with &#39;origin&#x2F;v1.0&#39;.</span><br></pre></td></tr></table></figure><p>不过这个时候要注意，由于 <code>sub-module</code> 没有被移除，因此切换到 <code>v1.0</code> 分支以后，你看到的 <code>sub-module</code> 文件夹依然是个子模块。也就是说，子模块穿越了时空来到了 <code>v1.0</code> 分支…… 嗯这个行为似乎不是我们期望的那个样子。</p><p>如果你真的想回到 <code>v1.0</code> 分支的非子模块的 <code>sub-module</code>，那你不得不在切换分支前把这个子模块卸载掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r sub-module</span><br><span class="line">git commit -m &quot;remove submodule&quot; </span><br><span class="line">git checkout v1.0</span><br></pre></td></tr></table></figure><p>如果你想从 <code>v1.0</code> 分支回到 <code>v2.0</code>，也会遇到一些问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;main-module$ git checkout v2.0</span><br><span class="line">M       sub-module</span><br><span class="line">Switched to branch &#39;v2.0&#39;</span><br><span class="line">Your branch is up-to-date with &#39;origin&#x2F;v2.0&#39;.</span><br><span class="line"></span><br><span class="line">~&#x2F;main-module$ git status</span><br><span class="line">On branch v2.0</span><br><span class="line">Your branch is up-to-date with &#39;origin&#x2F;v2.0&#39;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">  (commit or discard the untracked or modified content in submodules)</span><br><span class="line"></span><br><span class="line">        modified:   sub-module (modified content)</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>经过了 <code>git checkout -f v1.0</code> 和 <code>git checkout v2.0</code> 之后，子模块的文件竟然被 git 删掉了。而且这个时候无论是 <code>git submodule update</code> 还是 <code>git checkout -- sub-module</code> 都不好使了。到底应该怎么办呢？</p><p>答案是在子模块内部使用 <code>git reset</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;main-module&#x2F;sub-module$ git reset --hard HEAD</span><br><span class="line">HEAD is now at 359bce6 version 1.0 of sub-module</span><br><span class="line"></span><br><span class="line">~&#x2F;main-module&#x2F;sub-module$ git status</span><br><span class="line">HEAD detached at 359bce6</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>从这一部分的演示可以看出，<code>git submodule</code> 的设计对从已有文件拆分出来的子模块来说是非常糟糕的。或许这会成为大家尽量避免使用 git 子模块的原因之一吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在这篇文章中，我们来讲解一下 &lt;code&gt;git submodule&lt;/code&gt; 的实战用法，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册 git 子模块&lt;/li&gt;
&lt;li&gt;从已有的文件创建 git 子模块&lt;/li&gt;
&lt;li&gt;向上同步主仓库&lt;/li&gt;
&lt;li&gt;向下同步子模块仓库&lt;/li&gt;
&lt;li&gt;疑难杂症&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="tutorial" scheme="https://bitmingw.com/categories/tutorial/"/>
    
    
    <category term="git" scheme="https://bitmingw.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA 导航类快捷键指南</title>
    <link href="https://bitmingw.com/2018/06/17/intellij-idea-navigation-shortcut/"/>
    <id>https://bitmingw.com/2018/06/17/intellij-idea-navigation-shortcut/</id>
    <published>2018-06-17T07:00:00.000Z</published>
    <updated>2018-06-17T21:28:53.169Z</updated>
    
    <content type="html"><![CDATA[<p>在公司写过一年多的 Java 代码之后，我的直观感受是，每天大多数的时间都用于检索和阅览前人写的代码，而不是动手书写新的代码。我和大多数 Java 开发者一样，使用 Intellij IDEA 作为 Java 开发工具。因此，我认为有必要回顾开发流程，熟练掌握频繁使用的导航类快捷键，以便提升开发效率。</p><p>本文以 Windows / Linux 平台的快捷键进行讲解，Mac OS 请查看 Intellij IDEA 的 <a href="https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf" title="" target="">帮助文档</a>。</p><span id="more"></span><br /><h2 id="跨文件的跳转"><a href="#跨文件的跳转" class="headerlink" title="跨文件的跳转"></a>跨文件的跳转</h2><blockquote><p><code>Alt + LEFT / Alt + RIGHT</code> 切换到左侧/右侧的标签页。</p></blockquote><p>需要在两三个标签页之间来回切换时，这是最高效的方式。</p><blockquote><p><code>Ctrl + E</code> 在弹窗中打开最近浏览的文件。</p></blockquote><p>开发者下一个想要浏览的文件，通常最近刚刚浏览过。如果你打开的标签页比较多，或者你想要打开的标签页刚刚关闭（用 <code>Ctrl + F4</code> 关闭标签页），那么 <code>Ctrl + E</code> 通常是你跳转到下个文件的最快方法。</p><blockquote><p><code>Ctrl + B</code> 跳转到声明。<br><code>Ctrl + Alt + B</code> 跳转到定义。<br><code>Ctrl + Shift + I</code> 在弹窗中预览定义。<br><code>Ctrl + U</code> 跳转到父类/父类方法。</p></blockquote><p>上面四个快捷键的使用频率极高，请一定熟练掌握。</p><blockquote><p><code>Ctrl + N</code> 跳转到指定类。<br><code>Ctrl + Shift + N</code> 跳转到指定文件。<br><code>Ctrl + Shift + Alt + N</code> 跳转到指定符号。</p></blockquote><p>上面三个快捷键提供了项目内定向搜索的能力，比直接使用 <code>Ctrl + Shift + F</code> 甚至 <code>Double Shift</code> 搜索要快很多。</p><br /><h2 id="文件内的跳转"><a href="#文件内的跳转" class="headerlink" title="文件内的跳转"></a>文件内的跳转</h2><blockquote><p><code>Ctrl + G</code> 移动到指定行。</p></blockquote><p><code>Ctrl + G</code> 是一个在 debug 过程中非常有用的快捷键。Java 程序出现异常时，会打印 stack trace，这其中包含了出错的类名和抛出异常的行数。使用这个快捷键可以瞬间移动至那一行。</p><blockquote><p><code>Ctrl + LEFT / Ctrl + RIGHT</code> 光标向前/向后移动一个词。</p></blockquote><p>相当于 vi 中 <code>w</code> 和 <code>b</code> 的意义。适合在同一行近距离编辑使用。</p><blockquote><p><code>Alt + UP / Alt + DOWN</code> 移动至上一个/下一个方法。</p></blockquote><p>用这一对快捷键可以让你飞快地遍历整个文件！</p><blockquote><p><code>Ctrl + F12</code> 在弹窗中打开文件结构视图。</p></blockquote><p>相当于 <code>Alt + 7</code> 显示文件结构视图的弹窗版本。作用与 <code>Alt + UP / Alt + DOWN</code> 大同小异，都可以快速定位至文件内感兴趣的内容。它的好处在于避免眼花缭乱的跳转过程。</p><blockquote><p><code>F3 / Shift F3</code> 查找下一个/上一个。</p></blockquote><p>在搜索模式（<code>Ctrl + F</code>）下检索每一个找到的内容，相当于 vi 中 <code>n</code> 和 <code>N</code> 的意义。</p><br /><h2 id="生成关系图"><a href="#生成关系图" class="headerlink" title="生成关系图"></a>生成关系图</h2><blockquote><p><code>Ctrl + H</code> 显示继承关系树。<br><code>Ctrl + Alt + H</code> 显示调用关系树。</p></blockquote><p>这是两个非常强大的面向对象编程的工具。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在公司写过一年多的 Java 代码之后，我的直观感受是，每天大多数的时间都用于检索和阅览前人写的代码，而不是动手书写新的代码。我和大多数 Java 开发者一样，使用 Intellij IDEA 作为 Java 开发工具。因此，我认为有必要回顾开发流程，熟练掌握频繁使用的导航类快捷键，以便提升开发效率。&lt;/p&gt;
&lt;p&gt;本文以 Windows / Linux 平台的快捷键进行讲解，Mac OS 请查看 Intellij IDEA 的 &lt;a href=&quot;https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf&quot; title=&quot;&quot; target=&quot;&quot;&gt;帮助文档&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="info" scheme="https://bitmingw.com/categories/info/"/>
    
    
    <category term="programming" scheme="https://bitmingw.com/tags/programming/"/>
    
    <category term="intellij" scheme="https://bitmingw.com/tags/intellij/"/>
    
    <category term="productivity" scheme="https://bitmingw.com/tags/productivity/"/>
    
  </entry>
  
</feed>
